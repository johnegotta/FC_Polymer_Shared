<dom-module id="fc-mapped-grid">
 <template id="fc-mapped-grid-template">
 <style>
 section{
  background:white;
 }
:host{
	background: white;
	padding: 0px 3px 4px 8px;
	opacity: 1;

	position: static;
	@apply(--horizontal-layout);
	@apply(--layout-flex);
	}
  *{@apply(--layout-nowrap);}
 </style>
<!-- <paper-material class="onhooov" style="width:100%;">
<paper-button on-tap="abuseDom" style="width:40px; height: 50px; background: green;" >abuse</paper-button>
<section class="horizontal layout flex wrap self-shrink">
  <fc-input-prime input-type="select" is-repeater-selected="true" place-holder="{{arraySets.0.0}}"unless-select selected={{selected}} label="{{arraySets.0.0}}" select-items={{arraySets.0.1}}></fc-input-prime>
  <fc-input-prime input-type="select" label="{{arraySets.1.0}}" place-holder="{{arraySets.1.0}}" is-repeater-selected="true" unless-select selected={{selected}} select-items={{arraySets.1.1}}></fc-input-prime>
  <fc-input-prime input-type="select" label="{{arraySets.2.0}}" place-holder="{{arraySets.2.0}}" is-repeater-selected="true" unless-select selected={{selected}} select-items={{arraySets.2.1}}></fc-input-prime>
  <span style="position: relative; width: 66px; height: 46px;">
  <paper-swatch-picker on-down="pickColor">
  </paper-swatch-picker>
  </span>
</section>
</paper-material>
 -->
<a>
<div is-gridbox="true" class="horizontal layout flex self-stretch reverse" style="min-width:88.99vw; max-width:98.99vw; min-height: 91vh; max-height:96vh;">
<content></content>
<template is="dom-repeat"  class="horizontal layout flex" id="template" index-as="columnIndex" items="[[dataArrays]]">

    <div id="divCol[[columnIndex]]" class="vertical layout flex nowrap self-stretch" style="overflow-x: scroll;overflow-y: hidden; ">
          <section class="horizontal layout flex nowrap center center-justified" style="background: aliceblue; border: 2px #005c00 ridge; font-weight:700; color: #009; font-size: 20px; overflow: hidden; text-align: center;width:calc(100vw/18); max-height: 34px;">
              {{item.column}}
          </section>
         
                <template is="dom-repeat" id$="templateTwo_{{item.column}}" class="vertical flex layout" items="{{item.cell}}" style="padding-top: 30px;" as="cell">
                      <div location="{{cell.location}}" column="[[item.column]]" style="border:2px solid #009;">
                        <a link={{}}>
                              <section class="horizontal layout flex self-stretch item" location="{{cell.location}}" counter="0" drags draggable dragging is-gridbox="true" cell="{{cell}}" key="{{cell.key}}" value="{{cell.value}}" style$="min-width:calc(99%/18); min-height:calc(92vh/16); max-width: 220px; max-height:60px; background-color:#fff; border:4px solid #009; font-size:14px;" on-down="startDrag" on-dragover="allowDrop" on-up="handleDrop"id$="gridBox{{cell.key}}">
                 
                             <fc-input-search-select input-type="text" style="border-bottom: 3px white solid;min-width: 85px; min-height: 95px;" id$="input[[cell.key]]" drags dragging dragable on-change="adjustValueArrays" max-char="450" iss-class="cell" value="" iss-value="{{computeIssValueFunction(cell.key, cell.location, cell.value, cell)}}" key="{{cell.key}}" to-location="{{cell.location}}"></fc-input-search-select>
                            </section>
                        </a>
                    </div>
              </template>
          
    </div>
</template>

</div>
</a>
 </template>
 <script>
 FcMappedGrid=Polymer({
 	is:"fc-mapped-grid",
  behaviors:[Polymer.Templatizer],
 	properties: {
    theCoords:{
      type: Array,
      value:function(){return[];},
    },
    dragEl:{
      type: Object,
    },
    dataArrays:{
      type: Array,
      value:function(){return[];},
    },
    trueArrays:{
      type: Array,
      value: function(){return[];},
      notify: true,
    },
    stateMap:{
      type: Map,
      notify: true,
    },
 		gridMap:{
 			type:Map,
	 		},
    stateMap:{
      type: Map,
      observer:"observeStateMap",
      },
    instanceProps:{
        myGridMap: true,
        myStateMap: true,
      },
      issClass:{
        notify: true,
      },
      arraySets:{
        type:Function,
        value:function(){return [
                                  ["keyColors", 
                                          ["yellow","orange","#afafaf", "lightblue","lightgreen","red", "cornflowerblue"]
                                  ],

                                  ["numberOfHighlightColors",["one", "two", "2 plus one accent", "2 plus 2 accents", "3 plus 2 accents"]
                                  ],
                                  ["selectionOfFirstHighlightColor",["rowsOnly", "columnsOnly", "rowsAndColumns", "rowsAndSummations", "All"]
                                  ],//0th has key then val array
        ]
      },

	 	drags:{type: Boolean, value: function(){return true;}, notify: true},
	 	
 		},
  },
showvalues(e){
  //console.log(e.target, e);

},
computeIssValueFunction(theKey, loc, val, cell){
  console.log(theKey, loc, val, cell);




},
      _computeInputValue(one, two, three, four, five){
         //console.log("4","4","4","4","4","4");
         return four;


      },

      computeElementApiRequestsFromDataStar(needsAvalue){},
      adjustValueArrays(e){
        var index1 =e.model.cell.key.charAt(0), 
         index2=e.model.cell.key.charAt(1),
         val = e.target.value,
        valueStart =e.model.cell.value;
        //console.log(val, valueStart, index1, index2, e.model.cell.location, e.model.cell.key, "look for VALUES HERE", e);
      },


    ready(){

      var da=this.setDataArrays();
      this.set("dataArrays",da);
      var map=this.setMaps(da);
      var clone=da.map(function(item, index, array){  return item;});
      //console.log(clone);
      this.set("trueArrays",clone);
      },

      // var retsub=item.cell.map(function(it, i){return [it.val, it.value];}); console.log(retsub[index]);

      attached(){
      
      },
      abuseDom(){
          var tcs= this.$.template;
          var elems=Polymer.dom(this.root).getEffectiveChildNodes();
          var getChildren=Polymer.dom(tcs).getEffectiveChildNodes();
;
          console.log(tcs, elems, tcs.id, getChildren);
            
        //   while(templateChild.nodeName){
        //     templateChild = Polymer.dom(templateChild).nextSibling;
        //     }
        //     if(templateChild.nodeName=="TEMPLATE"){
        //       var target =templateChild;
        //       nodeArr.push(target);
        //       console.log(nodeArr);
        //     }
        //     else if(templateChild.nodeName==null){
        //       stepchild=Polymer.dom(templateChild).nextNode;
        //     }
        //     else{parent=parent.parentNode;}
        //    console.log(template, template)
        //        if(template.nodeName=="TEMPLATE" && template.id="template"){
        //             template.child

        //        }


                  
        // var instance = this.stamp({
        //                       myStateMap: this.stateMap,
        //                       myGridMap:this.gridMap,
        //                           });
        //   Polymer.dom(this).appendChild(instance.root);



      },
    setDataArrays(){
        var columnKeys=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];
        var columnNames=["Years","January","February","March","April","May","June","July","August","September","October","November","December","Year Total",`&#x0394`, `&#x0394`];
        var tempArr=[];
        var retArrays=columnKeys.map(function(val, index,array){
                    var count=array.length;
                    var tempArr=[];
                    var valueArray=[];
                    for(var i=0;i<count;i++)
                    {
                       var retMini= val+array[i];
                       tempArr.push({"key": retMini, "location": retMini, "value": retMini});
                       var value= "inputValue__"+index+"_"+i;
                       valueArray.push(value);
                    }
                   retVal={column: columnNames[index], cell: tempArr, values:valueArray};
                   //console.log()
                    return retVal;  
            }, []);
        //console.log(retArrays);
        return retArrays;
        },
    setMaps(da){
        var map=new Map(); 
        this.keys2=[];
        var stateMap=new Map();
       var sa= this.dataArrays.reduce(function(pre, val, index, array){
         return pre.concat(val.cell);
       },[]).forEach(function(vals, index, array){
        var key=vals.key;
        var value=[{"value": vals.value,"timestamp": new Date().getTime(),"userId": "userString", "location": vals.location}];
        map.set(key,value);
        var k2=vals.location;
        stateMap.set(k2,[vals.key, vals.value]);
       }, this);
       this.set("stateMap", stateMap);
       this.set("gridMap", map)
       //console.log("gridMap: ",map, "stateMap: ", stateMap);
       var mapPair=[map,stateMap];

       return mapPair;
        },
        getRows(){
          //console.log(this.stateMap);




        },
    updateMap(newKey, oldKey){
      var nkey= this.stateMap.get(newKey);
      var okey=this.stateMap.get(oldKey);
      this.stateMap.set(okey,nkey);
      this.stateMap.set(nkey,okey);
      this.updateHistory(newKey,oldKey);
      this.updateHistory(oldKey,newKey);
      console.log(newKey, oldKey, nkey, okey, this.stateMap, "here is the money");
    },
    observeStateMap(newVal, oldVal){
      //console.log(newVal, oldVal);
 

    },
   
    updateHistory(key, value){
      var ova=this.gridHistoryMap.get(key),
      nva=[value, new Date().getTime(),"userString"],
      setval=ova.push(nva);
      // this.gridHistoryMap.set(key, setval);
      //console.log(this.gridHistoryMap, this.gridHistoryMap.get(key));
    },
 	startDrag(e){
    e.preventDefault();
 			var targ=e.target;
 			while(targ.classList.contains("item")!==true && targ.nodeName!="PAPER-MATERIAL")
            {targ=targ.parentElement;}
 			if(targ.classList.contains("item")==true){
 				targ.drags=true;
        targ.draggable=true;
        var coords=targ.key;
       var theCoords=this.getIndex(coords);
               this.set("dragCoords",[theCoords,coords]);
               
        }
      },
   allowDrop(e){
          e.preventDefault();
        },
  handleDrop(e){
          var lt=e.detail.sourceEvent.toElement, bool=Polymer.dom(lt).classList.contains("item");
            while(!bool && lt.nodeName!="DIV")
              {
                lt=lt.parentElement;
                bool=Polymer.dom(lt).classList.contains("item");
              }
            var key=lt.key;
            var val=lt.value;
       
            var locator= this.getIndex(lt.key);
            newLocationArray=[[locator[0],locator[1]],key];
            var myKey=lt.key;
            var tempParent=lt.parentElement;
            while((tempParent && !tempParent._templateInstance)&&tempParent!=null){
              tempParent=tempParent.parentElement;
            }
          this.set(['trueArrays',this.dragCoords[0][0], "cell",this.dragCoords[0][1],"key"],myKey);
          this.set(['trueArrays',newLocationArray[0][0], 'cell',newLocationArray[0][1],'key'],this.dragCoords[1]);
    //set template instance data    
    e.model.set("cell.key",myKey);
    tempParent._templateInstance.dataHost.modelForElement(lt).set("cell.key", this.dragCoords[1]);
    //set instance data
            this.stateMap.set(this.dragCoords[1],[myKey, lt.value]);
            this.stateMap.set(newLocationArray[1],[this.dragCoords[1],this.trueArrays[newLocationArray[0][0]].cell[newLocationArray[0][1]].value]);
            //console.log(this.stateMap, this.dataArrays);
                //console.log(lt.cell, "look here for cell", lt.value, this.trueArrays);
             Polymer.dom.flush();

   
      
   
  },


  getIndex(cell){
    var index=cell.toString().charAt(0);
    var dex1=(index==="a")?10:(index==="b")?11:(index==="c")?12:(index==="d")?13:(index==="e")?14:(index==="f")?15:parseInt(index); 
    index=cell.charAt(1);
    var dex2=(index==="a")?10:(index==="b")?11:(index==="c")?12:(index==="d")?13:(index==="e")?14:(index==="f")?15: parseInt(index);
    return [dex1, dex2];
  },
  getCoordsFromIndex(ind){
    var index=ind[0];
    var dex1=(index==10)?"a":(index==11)?"b":(index==12)?"c":(index==13)?"d":(index==14)?"e":(index==15)?"f":parseInt(index);
    index=ind[1];
    var dex2=(index==10)?"a":(index==11)?"b":(index==12)?"c":(index==13)?"d":(index==14)?"e":(index==15)?"f":parseInt(index);
    index=ind[1];
    var retVal=dex1.toString()+dex2.toString();
    return retVal;
  }
	

  });
    </script>
   </dom-module>
   <!--
  
           // this.set(['dataArrays',newLocationArray[0][0], 'cell',newLocationArray[0][1],'location'],this.dragCoords[1]);
         // e.model.set("cell.location",myLoc);
         //    while(parent.nodeName!="TEMPLATE" && parent.nodeNam!="DOM-REPEAT" && parent.nodeName!="FC-DASHBOARD-ONE"){  console.log(parent.nodeName);
         //     if(parent.nodeName=="TEMPLATE"){  console.log(parent.nodeName);            }
         //       console.log(parent.nodeName);
         //    //   parent=Polymer.dom(parent).parentNode;
         //   }
         // console.log(lt, e.model.dataHost);
      //       var parent=Polymer.dom(lt).parentNode,
      // parent2=Polymer.dom(this.dragEl).parentNode,
      // nes=Polymer.dom(lt).nextSibling,
      // nes2=Polymer.dom(this.dragEl).nextSibling;
      //  Polymer.dom(parent2).insertBefore(lt, nes2);
      //  Polymer.dom(parent).insertBefore(this.dragEl, nes);
              


              // this.set(['dataArrays',newLocationArray[0][0], 'cell',newLocationArray[0][1],'location'],this.dragCoords[1]);
        
       
            // this.notifyPath(['dataArrays',newLocationArray[0][0], 'cell',newLocationArray[0][1],'location'],this.dragCoords[1]);
   //  if(this.isWrapper==true){
        //   var wrap=this.$$("fc-fit-wrapper");
        //  wrap.set("positionTarget", lt);
        //    wrap.specialRefit(lt);
        //  wrap.set("drags",false);
        //  this.set("isWrapper",false);
   // this.set(['dataArrays',this.dragCoords[0][0], "cell",this.dragCoords[0][1],"location"], e.model.__data__.cell.location);
      // this.set(['dataArrays',newLocationArray[0][0], 'cell',newLocationArray[0][1],'location'],loc);

      //this should key map the thing, will location map next
     // .cell[this.dragCoords[0][1]];
