<dom-module id="fc-indexed-database">
<style>
paper-item{
  border: 1px silver solid;
  margin: 1px;
  font-size: 14px; 
  font-family: merriweather;
}
paper-listbox{
  overflow-y: scroll;
  border: gold 4px ridge;
}
</style>
<template id="fc-indexed-database-template">
<paper-listbox>
<template is="dom-repeat" items="{{indexedDataBases}}">
<paper-item>
Name: {{item.name}}, Version: {{item.version}}, Columns: {{item.columns}}, Rows: {{item.rows}}, Size: {{item.size}}
</paper-item>
</template>   
</paper-listbox>
</template>
<script>
FcIndexedDatabase=Polymer({
  is: "fc-indexed-database",
  properties: {
    indexedDataBases:{
        type: Array,
        value:function(){return [];},
        notify: true,
      },
      userParams:{
          type:Object,
          value:function(){return {};},
          notify: true,
              //use a getter here to grab the params fom the login? 
              //from where firebase? uggh... should hold params in local storage 
              //with some funcadelic, woodblock, turing machine, encryption
      },
      dataArrays:{
          types: Array,
          value:function(){return [];},
          notify: true,
          observer: "observeDataArrays",//may want a higher level observer to hit some subproperties
      },

      sessionHistory:{
          type: Array, 
          value: function(){return [];},
          notify: true,
      },

      activeCell:{
          type: Object, 
          value: function(){return{};},
          notify: true,
          observer:"observeActiveCell",
      },

    },

  created(){},
  ready(){},
  attached(){
      if(this.dataArrays.length>0){
          this.initAllDatabases(this.dataArrays);
      }
      else{this.async(this.initAllDatabases(this.dataArrays), 230);}
  },
  detached(){},

  initAllDatabases(dataArrays){
        window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
        window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
        window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;

        // From here on, it's like using IndexedDB from content

        if (!window.indexedDB) {
          window.alert("Load Chrome; Your browser doesn't support our database.")
        }
        var counter=dataArrays.length;

        for(var j=0; j<counter;j++)
        {   var dataArray=dataArrays[j];
            var columns=dataArray.length;
            var rows=dataArray[0].length;
            var data =dataArray.map(function(colHolder, col){
                return colHolder;
                }).reduce(function(pre, val){
                    return pre.concat(val);
                },[]);
                console.log(data);
            var gridKey=dataArray[0][0].key.split("_");
            var gridName=gridKey[0];
            var version=1;
            var dbName = gridName; 
            var numObj=data.length;
            var indexedDataBaseObject={
                "name": gridName,
                "version": version, 
                "columns": columns,
                "rows": rows,
                "size": numObj,
                "objects": data,
            };
            this.push("indexedDataBases", indexedDataBaseObject); 
        
  //           var request = indexedDB.open(gridName, version);
  //           request.onsuccess=function(event){
  //               var db= event.target.result;
  //               var transaction =db.transaction("cell", "readonly");
  //                var objectStore = transaction.objectStore('contactsList');

  //                 var myIndex = objectStore.index('time'); 
  //                  myIndex.openCursor().onsuccess = function(event) {
  //   var cursor = event.target.result;
  //   if(cursor){ console.log(cursor.value.name, cursor.value.value, cursor.value.style);}
  //   cursor.continue();
  //   else{ console.log('Entries all displayed.');    
  //   }
  // };
  //               console.log(event, db);
  //   };
   this.setDataBase(gridName,version,data);
        request.onerror = function(event) {
                    console.log("db error");
              };

        request.onupgradeneeded = function(event) {
            var db = event.target.result;
            console.log(db);
            var gridObjectStore = db.createObjectStore("cell", { keyPath: "key" });
     
            gridObjectStore.createIndex("key", "key", { unique: true });
            gridObjectStore.createIndex("value", "value", { unique: false });
            gridObjectStore.createIndex("name", "name", { unique: false });
            gridObjectStore.createIndex("open", "open", {unique: false});
            gridObjectStore.createIndex("time", "time", {unique: false})
    
            };
            
           //data is from 68 above
     
              data=[];
          }// for loop ends here
        },

  observeActiveCell(ncv, ocv){

      if(ncv!=null){console.log(ncv, ocv);}

  },
  observeDataArrays(ndav, odav){
      if(ndav!=null){console.log(ndav, odav);}


  },
  setDataBase(gridName, version, data){

          var request = indexedDB.open(gridName, version);
          request.onsuccess = function(event) {   
                var db = event.target.result;
                var transaction = db.transaction("cell", "readwrite");
                console.log(db, "did i make it in here", gridName, j);
                var objectStore = transaction.objectStore("cell");
                    data.forEach(function(ca,i,a){
                          objectStore.put(ca);
                          console.log(ca, "in for each");
                    });
                           console.log("db created"); 
              };


  },

initializeDataArray(dataArray){
     
      var data =dataArray.map(function(colHolder){
            return colHolder;
        }).reduce(function(pre, val){
        return pre.concat(val);
        },[]);
      var gridKey=dataArray[0][0].key.split("_");
      var gridName=gridKey[0];
      var version=1;
    this.persistCells(gridName, version, data);
    },
 

  persistCells(gridName, version, data){
  	var jason=this;
  	console.log(data);//got hear stopped
  	var request = indexedDB.open(gridName, version);
  request.onupgradeneeded = function(event) {
    var db = event.target.result;
    console.log(db, "did i make it in here, HERE HERE HERE");
    var mapsObjectStore = db.createObjectStore("cell", { keyPath: "key" });
    
    mapsObjectStore.createIndex("key", "key", { unique: true });
	};
  var jason=this;
  var request = indexedDB.open(gridName, version);//"gridMaps"
  request.onsuccess = function(event) {
      
    var db = event.target.result;
    var transaction = db.transaction("cell", "readwrite");
     console.log(db, "did i make it in here");
    var objectStore = transaction.objectStore("cell");
    
        data.forEach(function(ca,i,a){
          objectStore.put(ca);
          console.log(ca, "in for each");
         });
    

    
    transaction.oncomplete = function() {
      console.log("cells saved", objectStore);
      console.log("db updated");
    };
    console.log("db updated");
  };
  
    
  
},
 
 addCellsToView(gridName, version){
  var cell1;
  var request = indexedDB.open("jasonGrid", 1);//"gridMap"
  var query;
  
  request.onsuccess = function(event) {
 
      var db = event.target.result;
 
      var transaction = db.transaction("cell", "readonly");
      var objectStore = transaction.objectStore("cell");
      
      query = objectStore.getAll();
      console.log(query);
      
      query.onerror = function(queryEvent) {
          console.log("Unable to retrieve data from database!");
        };
        
        query.onsuccess = function(queryEvent) {
          
          console.log(queryEvent.target.result);
           cell1 = queryEvent.target.result;
           var topArray=[];
           var lastVal=cell1.length-1;
          var columnArray =cell1.reduce(function(pre, val, i, arr){
            console.log(pre,val);
              if(pre.length==0){pre.push(val); return pre;}
              else {  
                      var last=pre.length-1;
                      var keys=pre[last].id.split("_");
                      var valKeys=val.id.split("_");
                      if(keys[1]==valKeys[1]&&i!==(lastVal)){pre.push(val); return pre;}
                      else if(keys[1]!=valKeys[1]){
                        topArray.push(pre); 
                        var newArr=[];
                        newArr.push(val);
                        return newArr;
                      }
                      else if(i==(lastVal)&&keys[1]==valKeys[1]){
                        pre.push(val);
                        topArray.push(pre);
                        return topArray;
                      }
                      else if(i==(lastVal)&&keys[1]!=valKeys[1]){
                        topArray.push(pre); 
                        var newArr=[];
                        newArr.push(val);
                        topArray.push(newArr);
                        return topArray;
                      }
                    }
           }, []);
          this.set("holderArray", columnArray);
 		console.log("successfully regrouped into", topArray.length,"number of columns, the following arrays of objects: ", this.holderArray);
   		
      // do stuff with the product
      // provide a callback parameter to execute here
          
        }.bind(this);
  }.bind(this);
 
}
});
</script>





<!--(function(){
// // "use strict";
// window.indexedDB = window.indexedDB || window.mozIndexedDB || window.webkitIndexedDB || window.msIndexedDB;
 
// window.IDBTransaction = window.IDBTransaction || window.webkitIDBTransaction || window.msIDBTransaction;
// window.IDBKeyRange = window.IDBKeyRange || window.webkitIDBKeyRange || window.msIDBKeyRange;

// // From here on, it's like using IndexedDB from content

// if (!window.indexedDB) {
//    window.alert("Your browser doesn't support a stable version of IndexedDB.")
// }
 
// const dbName = "jasonGrid";
 
// var request = indexedDB.open(dbName, 1);
 
// request.onerror = function(event) {
//     console.log("db error");
// };
 
// request.onupgradeneeded = function(event) {
//     var db = event.target.result;
//     // self.FCBehaviors.FcGridInitializerBehavior.set("dataBaseProxy", db);
 
//     var mapsObjectStore = db.createObjectStore("cell", { keyPath: "key" });
    
//     mapsObjectStore.createIndex("key", "key", { unique: true });
    
//     self.FCBehaviors.FcGridInitializerBehavior.persistCells(this.data);
//     console.log("db created"); 
//   };
// })();

-->