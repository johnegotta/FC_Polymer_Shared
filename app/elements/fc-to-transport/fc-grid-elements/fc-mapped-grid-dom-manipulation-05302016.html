<dom-module id="fc-mapped-grid">
 <template id="fc-mapped-grid-template">
 <style>
 section{
  background:white;
 }
:host{
	background: white;
	padding: 0px 3px 4px 8px;
	opacity: 1;

	position: static;
	@apply(--horizontal-layout);
	@apply(--layout-flex);
 @apply(--layout-fit);
	}
 </style>
<!-- <fc-ddr-card id="focusedGrid" is-gridbox="true" head-class="darkBlue"  is-picker="true" header-title="Focus Grid" class="<content></content>" start-ht="91vh" style="padding-right:2px; width: 98%!important;">  -->
<a>
<div is-gridbox="true" class="horizontal layout flex self-stretch reverse" style="min-width:99.99vw; max-width:99.99vw; min-height: 91vh;">
<content></content>
<fc-relative-fit-wrapper class="wrapper item" drags draggable dragging style="position: absolute;" on-down="dragStart" on-up="handleDrop"></fc-relative-fit-wrapper>
<template is="dom-repeat"  class="horizontal layout flex" id="template" index-as="columnIndex" items="[[dataArrays]]">

<div id="divCol[[columnIndex]]" class="vertical layout flex nowrap self-stretch">
<h4>{{item.column}}</h4>
<template is="dom-repeat" id="templateTwo" class="vertical flex layout" items="{{item.cell}}" as="cell">
<div location="{{cell.key}}" column="[[item.column]]">
<section class="horizontal layout flex self-stretch item" location="[[cell.location]]" counter="0" drags draggable dragging is-gridbox="true" key="{{cell.key}}" style$="min-width:calc(96vw/16); min-height:calc(96vh/16); max-width: 120px; max-height:182px; background-color:#ffff[[cell.key]]; border:2px solid #009; font-size:14px;" on-down="startDrag" on-dragover="allowDrop" on-up="handleDrop"id$="gridBox{{cell.key}}">

{{cell.location}}
<fc-input-prime input-type="text" id$="input[[cell.key]]" on-change="adjustValueArrays" input-style="max-width: 50px; max-height: 50px;" label="[[cell.key]]" value="{{cell.value}}" key="[[cell.key]]" to-location="[[cell.location]]" ></fc-input-prime>
</section>
</div>
</template>
</div>
</template>

</div>
</a>
<!-- </fc-ddr-card> -->
 </template>
 <script>
 FcMappedGrid=Polymer({
 	is:"fc-mapped-grid",
 	properties: {
    theCoords:{
      type: Array,
      value:function(){return[];},
    },
    dragEl:{
      type: Object,
   
    },
    valueObject:{
      value:function(){return 6;},
      notify: true

    },
    dataArrays:{
      type: Array,
      value:function(){return[];},
      notify: true
    },
    trueArrays:{
      type: Array,
      value: function(){return[];},
      notify: true,
    },
    valuesMap:{
      type: Map,

    },
    eventModelCell:{
      type: Object,
    },
    dropTargetCellObject:{
      type: Object,

    },
 		gridHistoryMap:{
 			type:Map,
	 		},
      stateMap:{
         type: Map,
         observer:"observeStateMap",
     
      },
      currentHeight:{
        notify:true,
      },
      currentWidth:{
        notify: true,
      },
    isWrapper:{
      type: Boolean,
      value: false,
      notify: true
    },

	 	drags:{type: Boolean, value: function(){return false;}, notify: true},
	 	
 		},

      _computeInputValue(one, two, three, four, five){
         console.log("4","4","4","4","4","4");
         return four;


      },
      adjustValueArrays(e){
        var index1 =e.model.cell.key.charAt(0), 
         index2=e.model.cell.key.charAt(1),
         val = e.target.value,
        valueStart =e.model.cell.value;
        console.log(val, valueStart, index2, index1);



      },


    ready(){
      var da=this.setDataArrays();
      this.set("dataArrays",da);
      //var map=this.setMaps(da);
      var clone=da.map(function(item, index, array){  return item;});
      console.log(clone);
      this.set("trueArrays",clone);
      // this.set("gridHistoryMap",map[0]);
      // this.set("stateMap", map[1]);
      },

      // var retsub=item.cell.map(function(it, i){return [it.val, it.value];}); console.log(retsub[index]);

      attached(){
         this.async(
          this.initializeValuesMap, 8300);

      },
    setDataArrays(){
        var columnKeys=["0","1","2","3","4","5","6","7","8","9","a","b","c","d","e","f"];
        var tempArr=[];
        var retArrays=columnKeys.map(function(val, index,array){
                    var count=array.length;
                    var tempArr=[];
                    var valueArray=[];
                    for(var i=0;i<count;i++)
                    {
                       var retMini= val+array[i];
                       tempArr.push({"key": retMini, "location": retMini, "value": retMini});
                       var value= "inputValue__"+index+"_"+i;
                       valueArray.push(value);
                    }
                   retVal={column: val, cell: tempArr, values:valueArray};
                    return retVal;  
            }, []);
        console.log(retArrays);
        return retArrays;
        },
    setMaps(da){
        var map=new Map(); 
        this.keys2=[];
        var valMap=new Map();
        var stateMap=new Map();
       var sa= this.dataArrays.reduce(function(pre, val, index, array){
         return pre.concat(val.cell);
       },[]).forEach(function(vals, index, array){
        var key=vals.key;
        var value=[[vals,new Date().getTime(),"userString"]];
        map.set(key,value);
        var changeRecord={"currentValue":vals.location, "changeRecord": value};
        valMap.set(key,changeRecord);

        stateMap.set(key,vals.val);
       }, this);
       this.set("valuesMap", valMap);
       console.log("map: ",map, "stateMap: ", stateMap, "valuesMap", valMap);
       var mapPair=[map,stateMap];

       return mapPair;
        },
    updateMap(newKey, oldKey){
      var nkey= this.stateMap.get(newKey);
      var okey=this.stateMap.get(oldKey);
      this.stateMap.set(okey,nkey);
      this.stateMap.set(nkey,okey);
      this.updateHistory(newKey,oldKey);
      this.updateHistory(oldKey,newKey);
      console.log(newKey, oldKey, nkey, okey, this.stateMap, "here is the money");
    },
    observeStateMap(newVal, oldVal){
      console.log(newVal, oldVal);
      this.async(
      this.initializeValuesMap, 8500);

    },
    initializeValuesMap(){
      var vmap=new Map();
     var parent=this.$.template;
     // console.log(parent); why 10 times?
         //var  primeArray=Polymer.dom(parent).querySelectorAll("template[is='dom-repeat']");
         // template[is="dom-repeat"]
         
      
     //     var smkeys=this.stateMap.keys();
     // console.log(smkeys);
     // var mappedParray=primeArray.map(function(val, i, index){
     //   var key=smkeys.next().value;
     //     vmap.set(key, [val, val.value]);
     //     return [key, val.value];
     //  });
     // //console.log(vmap);
     // this.set("valuesMap", vmap);
    // console.log(this.valuesMap, "this is the coolest map ever");
    },
    updateHistory(key, value){
      var ova=this.gridHistoryMap.get(key),
      nva=[value, new Date().getTime(),"userString"],
      setval=ova.push(nva);
      // this.gridHistoryMap.set(key, setval);
      console.log(this.gridHistoryMap, this.gridHistoryMap.get(key));
    },
 	startDrag(e){
    e.preventDefault()
 			var targ=e.target;
 			while(targ.classList.contains("item")!==true && targ.nodeName!="PAPER-MATERIAL")
            {targ=targ.parentElement;}
 			if(targ.classList.contains("item")==true){
 				targ.drags=true;
 				targ.dragging=true;
        targ.draggable=true;
        console.log(targ);
        var coords=targ.location;
        console.log(coords, "look here");
       var theCoords=this.getIndex(coords);
              this.set("eventModelCell", e.model.__data__.cell.location);
               console.log(e.model.__data__.cell, "startHere, thenpass");
               this.set("dragCoords",[theCoords,coords]);
               console.log(this.dragCoords);
               this.set("dragEl", targ);
          console.log(e);
        }
      },
   allowDrop(e){
          e.preventDefault();
        },
  handleDrop(e){
          var lt=e.detail.sourceEvent.toElement, bool=Polymer.dom(lt).classList.contains("item");
            while(!bool && lt.nodeName!="DIV")
              {
                lt=lt.parentElement;
                bool=Polymer.dom(lt).classList.contains("item");
              }
            var loc=lt.location;
            console.log(lt.location, "loook here");
            var locator= this.getIndex(lt.location);
            newLocationArray=[[locator[0],locator[1]],loc];
            var myLoc=lt.location;
            console.log(e, lt, myLoc);
              console.log(this.dragCoords[0][0], this.dragCoords[0][1], newLocationArray[0][0], newLocationArray[0][1])
            this.set(['trueArrays',this.dragCoords[0][0], "cell",this.dragCoords[0][1],"location"],myLoc);
            this.set(['trueArrays',newLocationArray[0][0], 'cell',newLocationArray[0][1],'location'],this.dragCoords[1]);
              e.model.set("cell.location",myLoc);
            // while(parent.nodeName!="TEMPLATE" && parent.nodeNam!="DOM-REPEAT" && parent.nodeName!="FC-DASHBOARD-ONE"){
            //   if(parent.nodeName=="A"){              parent=Polymer.dom(parent).parentNode;}
            //   console.log(parent.nodeName);
            //   parent=Polymer.dom(parent).parentNode;
            // }
         console.log(lt, e.model.dataHost);
            // parent.modelForElement(lt).set("cell.location", this.dragCoords[1]);
            
            var parent=Polymer.dom(lt).parentNode,
      parent2=Polymer.dom(this.dragEl).parentNode,
      nes=Polymer.dom(lt).nextSibling,
      nes2=Polymer.dom(this.dragEl).nextSibling;
       Polymer.dom(parent2).insertBefore(lt, nes2);
       Polymer.dom(parent).insertBefore(this.dragEl, nes);
       Polymer.dom.flush();
   
      
   
  },


  getIndex(cell){
    var index=cell.toString().charAt(0);
    var dex1=(index==="a")?10:(index==="b")?11:(index==="c")?12:(index==="d")?13:(index==="e")?14:(index==="f")?15:parseInt(index); 
    index=cell.charAt(1);
    var dex2=(index==="a")?10:(index==="b")?11:(index==="c")?12:(index==="d")?13:(index==="e")?14:(index==="f")?15: parseInt(index);
    return [dex1, dex2];
  },
  getCoordsFromIndex(ind){
    var index=ind[0];
    var dex1=(index==10)?"a":(index==11)?"b":(index==12)?"c":(index==13)?"d":(index==14)?"e":(index==15)?"f":parseInt(index);
    index=ind[1];
    var dex2=(index==10)?"a":(index==11)?"b":(index==12)?"c":(index==13)?"d":(index==14)?"e":(index==15)?"f":parseInt(index);
    index=ind[1];
    var retVal=dex1.toString()+dex2.toString();
    return retVal;
  }
	

  });
    </script>
   </dom-module>
   <!--//  if(this.isWrapper==true){
        //   var wrap=this.$$("fc-fit-wrapper");
        //  wrap.set("positionTarget", lt);
        //    wrap.specialRefit(lt);
        //  wrap.set("drags",false);
        //  this.set("isWrapper",false);
   // this.set(['dataArrays',this.dragCoords[0][0], "cell",this.dragCoords[0][1],"location"], e.model.__data__.cell.location);
      // this.set(['dataArrays',newLocationArray[0][0], 'cell',newLocationArray[0][1],'location'],loc);

      //this should key map the thing, will location map next
     // .cell[this.dragCoords[0][1]];
