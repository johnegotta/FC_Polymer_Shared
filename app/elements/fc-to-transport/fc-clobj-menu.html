  <dom-module id="fc-clobj-menu">
  <template>
  <style>
 	.gradBackground{		
		background: linear-gradient(to Top, #fff 2%,#1e5799 22%,#fff 42%,#fff 57%,#7db9e8 68%);
	}
:host{	overflow-x: scroll;
		overflow-y: hidden;
	/*	margin-right: 50%;
		margin-left: 50%;*/

		@apply(--horizontal-layout);
		@apply(--flex-layout-nowrap);
	}


.blue-btn-class{
 display: inline-block;
 border:6px solid #2435C9;
 color: #FFFFFF;
 border-radius: 180px 180px 180px 180px;
 -webkit-border-radius: 180px 180px 180px 180px;
 -moz-border-radius: 180px 180px 180px 180px;
 font-family: Merriweather;
width: 20px;
 height: 20px;
 margin: 2px;
 margin-top: 4px;
 font-size: 13px;
 padding: 3px;
 /*box-shadow: 3px 14px 11px 4px #9fafaf;*/
 /*box-shadow: 3px 4px 11px 3px #bebebe;
 -moz-box-shadow: 3px 4px 11px 3px #41398A;
 -webkit-box-shadow: 3px 4px 11px 3px #41398A;*/
 /*text-shadow: 0 1px 0 #FFFFFF;*/
 background-color: #5DD7FC;
}
.blue-btn-class:hover, .blue-btn-class:active, .thefocus{
	 display: inline-block;
 border:6px solid #2435C9;
 color: #FFFFFF;
 border-radius: 180px 180px 180px 180px;
 -webkit-border-radius: 180px 180px 180px 180px;
 -moz-border-radius: 180px 180px 180px 180px;
 font-family: Merriweather;
width: 20px;
 height: 20px;
 margin: 2px;
 margin-top: 4px;
 font-size: 13px;
 padding: 3px;
	padding: 6px 6px;
 border:6px solid gold;
 z-index:50000;
 color: #FFD410;
 box-shadow: inset 0 1px 0 0 #FFF6CE,inset 0 -1px 0 0 #E3C852,inset 0 0 0 1px #FCE88D;
 -moz-box-shadow: inset 0 1px 0 0 #FFF6CE,inset 0 -1px 0 0 #E3C852,inset 0 0 0 1px #FCE88D;
 -webkit-box-shadow: inset 0 1px 0 0 #FFF6CE,inset 0 -1px 0 0 #E3C852,inset 0 0 0 1px #FCE88D;
 background-color: #5DD7FC;
}
	</style>
<section style="width:100%; min-height: 22px; font-size: 18px; color: #008; font-family: merriweather; font-weight: 600;">	{{app.title}}</section>
<!-- <iron-selector selected="{{selected}}" class="horizontal layout center-justified nowrap" items="{{iconArrayA}}"> -->
	<!-- <section on-tap="selectPrevious"><iron-icon icon="icons:chevron-left"></iron-icon></section> -->
	<paper-tabs 
			      		id="assistantMenu" 
			      		scrollable="true"
			      		style="padding: 2px 0px; max-height: 96px; min-height: 32px; min-width: 120px;" on-tap="clickHandler"
			      		bar="true"
			      		hide-scroll-buttons="true" 
			  			> 
<section  class="horizontal layout around-justified nowrap" style="overflow-x: scroll; padding: 0px 0px;">
  				<template 
  				id="content"
					is='dom-repeat' 
						class="horizontal layout flex nowrap justified" 
						items="{{iconArrayA}}">
						<section 
							style$="[[computedStyle(determine)]]" 
							data-transition$="[[item.dDialogTwo]]"
							on-mouseover="labeler"
							
							 drags="true"
							 label$={{item.label}}>
							<iron-icon 
								drags="true"
								id$="[[item.dDialogTwo]]"
				        		icon$="[[item.iconUsed]]"  
				        		class$="[[item.sectionClass]]"
				        		data-transition$="[[item.dDialogTwo]]"
				        		label$="{{item.label}}"
				        		
				      			>
							</iron-icon>
						</section>
					</template>
	</section>
	</paper-tabs>
		<!-- <section></section> on-tap="selectNext"><iron-icon icon="icons:chevron-right"></iron-icon -->
<!-- 	</iron-selector> -->

</template>
<script>
FcClobjMenu=Polymer({
	is:"fc-clobj-menu",
	properties:{
		iconArrayA:{
			type: Array,
			computed: "_computeIconArrayA(iconArray)",
			notify: true
		},
		iconArray:{
			type: Array,
			value: function(){
				return [
					{	"sectionClass": "normal blue-btn-class",
						"dDialogOne": "loginMenu",
						"iconUsed": "icons:account-circle",
						"iconClass": "menuItems-dark", 
						"dDialogTwo": "loginMenu", 
						"label": 	"Login & Profile"
					},
					{	"sectionClass": "normal blue-btn-class",
						"dDialogOne": "dragAdmin",
						"iconUsed": "icons:hardware:dock",
						"iconClass": "menuItems-dark", 
						"dDialogTwo": "dragAdmin",
						"label":"The Focused Assistant"
					},
					
					{	"sectionClass": "normal blue-btn-class",
						"dDialogOne": "toDoList",
						"iconUsed": "icons:list",
						"iconClass": "menuItems-dark", 
						"dDialogTwo": "toDoList", 
						"label": "To-dos & Syllabus"
					},
					{	"sectionClass": "normal buttons blue-btn-class",
						"dDialogOne": "completedTasks",
						"iconUsed": "icons:toc",
						"iconClass": "menuItems-dark", 
						"dDialogTwo": "completedTasks",
						"label": "Completed Tasks"
					},
					{	"sectionClass": "normal buttons blue-btn-class",
						"dDialogOne": "clockTimer",
						"iconUsed": "icons:alarm-on",
						"iconClass": "menuItems-dark", 
						"dDialogTwo": "clockTimer", 
						"label": "Timers & Clocks",
						"selected": 1
					},
					{	"sectionClass": "normal buttons blue-btn-class",
						"dDialogOne": "firePadPrime",
						"iconUsed": "icons:spellcheck",
						"iconClass": "menuItems-dark", 
						"dDialogTwo": "firePadPrime",
						"label": "Notepad"
					},
					{	"sectionClass": "normal buttons blue-btn-class",
						"dDialogOne": "geoCalculator",
						"iconUsed": "icons:view-module",
						"iconClass": "menuItems-dark", 
						"dDialogTwo": "geoCalculator", 
						"label": "Focused Calculator"
					},
					{	"sectionClass": "normal buttons blue-btn-class",
						"dDialogOne": "calendar",
						"iconUsed": "icons:today",
						"iconClass": "menuItems-dark", 
						"dDialogTwo": "calendar",
						"label": "Focused Calendar"
					},
					{	"sectionClass": "normal buttons blue-btn-class",
						"dDialogOne": "readView",
						"iconUsed": "icons:chrome-reader-mode",
						"iconClass": "menuItems-dark", 
						"dDialogTwo": "readView",
						"label": "Reading Focus"
					},
					{	"sectionClass": "normal buttons blue-btn-class",
						"dDialogOne": "howWeDoin",
						"iconUsed": "icons:assessment",
						"iconClass": "menuItems-dark", 
						"dDialogTwo": "howWeDoin",
						"label": "Chart Your Progress"
					},
					{	"sectionClass": "normal buttons blue-btn-class",
						"dDialogOne": "whatToSee",
						"iconUsed": "icons:visibility",
						"iconClass": "menuItems-dark", 
						"dDialogTwo": "whatToSee",
						"label": 	"Things To See"

					},
					{	"sectionClass": "normal buttons blue-btn-class",
						"dDialogOne": "starRated",
						"iconUsed": "icons:stars",
						"iconClass": "menuItems-dark", 
						"dDialogTwo": "starRated",
						"label": "Focused LeaderBoard"
					}
				];
			},
		notify: true
	},
	scrollStyle: {
       type: String,
       value: 'horizontal'
      },
    app: {
    	type: Object,
    	value: {
    		title:"",
    		selected: Number,
    		controls:[],
    		icons:[],
    		methods:[],
    		notify: true
    	},
    	notify: true,
    	reflectToAttribute: true
    },
    selected:{
    	type: Number,
    	notify: true
    },
     

    
            swipeStyle: {
       type: String,
       value: 'horizontal'
      },
      /**
       * If true, then the container will not allow swiping.
       */
      disabled: {
        type: Boolean,
        value: false
      },
      /**
       * The ratio of the width of the element that the translation animation
       * should happen over. For example, if the `widthRatio` is 3, the
       * animation will take place on a distance 3 times the width of the
       * element being swiped.
       */
      widthRatio: {
       type: Number,
       value: 3
      },
      /**
       * The ratio of the total animation distance after which the opacity
       * transformation begins. For example, if the `widthRatio` is 1 and
       * the `opacityRate` is 0.5, then the element needs to travel half its
       * width before its opacity starts decreasing.
       */
      opacityRate: {
       type: Number,
       value: 0.2
      },
      /**
       * The CSS transition applied while swiping.
       */
      transition: {
        type: String,
        value: '300ms cubic-bezier(0.4, 0.0, 0.2, 1)'
      }, 
      count: {
      	type: Number, 
      	value: 0,
      	notify: true
      }
	},



	_computeIconArrayA: function(iconArray){
				var arr=[];
				for(j=0; j<3;j++){
				for(i=0; i<iconArray.length;i++){
				arr.push(iconArray[i]);
				}
			}
			return arr;
	},
	computedStyle: function(determine){
						 return "margin: 6px;";},



	ready: function() {
			var len=this.iconArrayA.length;
			var sel= Math.floor(len/2);
			console.log(sel);
			this.set("selected", sel);
			console.log("this is the selected", this.selected);
		      this._transitionProperty = 'opacity, transform';
		      this._slideComplete = false;
		      this._direction = "horizontal";
		      
    
		    },


    labeler: function(e, detail){
    	var elem=e.target;
        console.log(elem);
        var label=elem.attributes.label.value;
        this.set("app.title",label);
        console.log(this.appTitle);
      var glowing= Polymer.dom(this.root).querySelectorAll(".thefocus");
      console.log(glowing, "this is the nodelist");
      	var len=glowing.length;
      	var lastm = len-1;
      	var last=glowing[lastm];
      	var first =glowing[0];
      	var firstListener = this.addEventlistener(first);
      	
      	var lastlistener = this.addEventlistener(last);
      	var distanceR=Polymer.dom(this).getBoundingClientRects(this.$.content).right;
      	var dist2L = Polymer.dom(this).getBoundingClientRects(this.$.content).left;
      	var last2r= Polymer.dom(this).getBoundingClientRects(last).right;
      	var first2= Polymer.dom(this).getBoundingClientRects(first).left;
      	console.log(distanceR,dist2L,last2r,first2);
      	for(i=0; i<len; i++){
      		glowing[i].classList.remove("thefocus");
      		if(glowing[i].b){}
      	}
        if(elem.nodeName=="IRON-ICON"){
        elem.classList.add("thefocus");
    	}
    	else if(elem.nodeName=="SECTION"){
    		elem=elem.firstElementChild;
    		if(elem.nodeName=="IRON-ICON")
    		{
    		elem.classList.add("thefocus");
    		}
    	}

 	},
		clickHandler: function(e) {
			console.log(e);
			if(e.target.selected!=undefined){
				var sel = e.target.selected;
				this.set("app.selected", sel);
			}
		  var button = e.target;
		  while (!button.hasAttribute('data-transition') && button!==document.body) {
		    button = button.parentElement;
		  }
		  if (!button.hasAttribute('data-transition')) {
		    return;
		  }
		  var id = button.getAttribute('data-transition');
		  var dialog = document.getElementById(id);
		  console.log(document.getElementById(id), id);
		  if (dialog) {
		    dialog.open();
		  }
		},

	
attached:function(){
		 this._nodeObserver = Polymer.dom(this.$.content).observeNodes(
          function(mutations) {console.log(mutations.length, mutations.length);
          var child=this.$.content.firstElementChild;
          while(child.classList.contains("blue-btn-class")!=true && child!=this.$.content){child=child.nextSibling;}
          	if(child.classList.contains("blue-btn-class")==true){counter++; this.set("count", counter);console.log(counter, counter, counter, "this is where you look");}
          }.bind(this));
    },
    _addListeners: function(node) {
      if (node.nodeType === Node.TEXT_NODE || node.nodeType === Node.COMMENT_NODE)
        return;
      // Set up the animation.
      if(node.nodeName=="IRON-ICON" && node.nextSibling.nextSibling.nodeName!=="IRON-ICON")
      node.style.transitionProperty = this._transitionProperty;
      node.style.transition = this.transition;
      this.listen(node, 'track', '_onTrack');
      this.listen(node, 'transitionend', '_onTransitionEnd');
      if(node.nodeName=="IRON-ICON"){console.log(node);}
    },
    _removeListeners: function(node) {
      if (node.nodeType === Node.TEXT_NODE)
        return;
      this.unlisten(node, 'track', '_onTrack');
      this.unlisten(node, 'transitionend', '_onTransitionEnd');
    },
    detached: function() {
      if (this._nodeObserver) {
        Polymer.dom(this.$.content).unobserveNodes(this._nodeObserver);
        this._nodeObserver = null;
      }
    },
    _onTrack: function(event) {
      if (this.disabled)
        return;
      var target = event.currentTarget;
      if (target.classList.contains('disable-swipe'))
        return;
      var track = event.detail;
      if (track.state === 'start') {
        this._trackStart(track, target);
      } else if (track.state === 'track') {
        this._trackMove(track, target);
      } else if (track.state === 'end') {
        this._trackEnd(track, target);
      }
    },
    _trackStart: function(event, target) {
      // Save the width of the element, so that we don't trigger a style
      // recalc every time we need it.
      this._nodeWidth = target.offsetWidth;
      target.style.transition = 'none';
    },
    _trackMove: function(event, target) {
      this._animate(event.dx, target);
    },
    _trackEnd: function(event, target) {
      // The element is swiped away if it's moved halfway its total width.
      this._swipeComplete = Math.abs(event.dx) > this._nodeWidth / 2;
      this._direction = event.dx > 0;
      this._swipeEnd(target);
    },
    _animate: function(x, target) {
      var direction = x > 0 ? 1 : -1;
      // This is the total distance the animation will take place over.
      var totalDistance = this._nodeWidth * this.widthRatio;
      // Opacity distance overflow. `this._nodeWidth * this.opacityRate` is the
      // total distance the element needs to travel to become completely
      // transparent, and `x` is how much the element has already travelled.
      var opaqueDistance = Math.max(0, Math.abs(x) - this._nodeWidth * this.opacityRate);
      var opacity = Math.max(0, (totalDistance - opaqueDistance) / totalDistance);
      target.style.opacity = opacity;
      var translate, rotate;
      if (this.swipeStyle === 'horizontal') {
        translate = 'translate3d(' + x + 'px,' + 0 + 'px,0)';
        rotate = '';
      } else {  // Default is assumed to be `curve`.
        // Assume the element will be completely transparent at 90 degrees, so
        // figure out the rotation and vertical displacement needed to
        // achieve that.
        var y = totalDistance - Math.sqrt(totalDistance * totalDistance - opaqueDistance * opaqueDistance);
        var deg = (1 - opacity) * direction * 90;
        translate = 'translate3d(' + x + 'px,' + y + 'px,0)';
        rotate = ' rotate(' + deg + 'deg)';
      }
      this.transform(translate + rotate, target);
    },
    _swipeEnd: function(target) {
      // Restore the original transition;
      target.style.transition = this.transition;
      if (this._swipeComplete) {
        // If the element is ready to be swiped away, then translate it to the full
        // transparency distance.
        var totalDistance = this._nodeWidth * this.widthRatio;
        this._animate(this._direction ? totalDistance : -totalDistance, target);
      } else {
        this._animate(0, target);
      }
    },
    _onTransitionEnd: function(event) {
      var target = event.currentTarget;
      if (this._swipeComplete && event.propertyName === 'opacity') {
        Polymer.dom(this).removeChild(target);
        this.fire('iron-swipe',
            { direction: this._direction > 0 ? 'right' : 'left',
              target:target
            });
      }
    }



		
});
</script>
</dom-module>