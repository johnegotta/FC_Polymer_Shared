<dom-module id="fc-date-mini">
<template>
<style>
.pretty{

background: red;
height: 11px;
width: 30px;

}
.test {height: 100px; width: 100px; background: red;}
</style>
		<section class="vertical layout flex self-shrink" on-tap="toggleDays" style="background: [[computePickedDaysDark(inMonth, calendarDay.isSelected)]]  {{calendarDay.background}}; border: 1px solid #afafaf; border-top: 2px solid #afafaf; border-bottom: 3px solid {{calendarDay.background}} ;margin: 1px 1px 1px 0px;height: 100%;"><content select=".pretty"></content>
			<section class="horizontal layout" style="font-size:8px;font-weight: 600; width: 100%;background: [[computeWhite(inMonth, calendarDay.isSelected)]]; border-bottom: [[calendarDay.background]] 6px solid; border-right: 2px solid #afafaf; text-align: center;" >
				
			</section>
			<content select=".hwk"></content>
			<span class="horizontal layout flex center-justified"style="margin: 2px auto 1px auto; height: 20px; width: 20px; border-radius: 180px; font-size: 15px; cursor: pointer; border: 1px solid [[computeWhite(inMonth, calendarDay.isSelected)]]; background: [[computePickedDaysDark(inMonth, calendarDay.isSelected)]]; text-align: center; color: [[computePickedDaysWhite(inMonth, calendarDay.isSelected,calendarDay.isTestDate)]];"> <content select=".date"></content></span>
			<span style="font-size:10px; font-weight: 600; font-style: merriweather; color: #008; height: 10px;">[[computeDayNotes(calendarDay)]]</span>  
		</section>
</template>
<script>
Polymer({
	is:"fc-date-mini",
	behaviors: [FCBehaviors.FcCalendarBehaviorPrime],
	observer:["observeBackground(calendarDay.*)"],
	properties: {
		day:{
			type: FcCalendarDay,
			value:{},
			observer: "observeTheDays",
			notify: true
		},
		inCourseCalendarDaysArray:{
			type: Boolean,
			computed: "computeInCourseCalendarDaysArray(calendarDay)",
			notify: true
		},
		calendarDay:{
			type: FcCalendarDay,
			value:{},
			notify: true
		}, 
		isCourseMeeting: {
			type: Boolean,
			value:false,
			notify: true
		},
		isPracticeTestDay:{
			type: Boolean, 
			value: false,
			notify: true
		},
		miniDate:{
			type: Date, 
			computed: "computeMiniDate(calendarDay)",
			notify: true,
		},
		event:{
			type: FcCourse,
			value: function(){var retVal = new FcCourse(); return retVal;},
			notify: true

		},
		toggleDay:{
			type: Boolean,
			value: false, 
			notify: true
		}, 
		inMonth: {
			type: Boolean,
			value: false,
			 reflectToAttribute: true,
			 notify: true
		}, 
		dayId:{
			type: Number, 
			computed:"computeDayId(calendarDay)",
			notify: true
		},
		events:{
			type: Array,
			observer: "isEvents",
			notify: true
		},
		displayedMonth:{
			type: Array,
			notify: true
		},
		displayedIndex:{
			type: Number,
			notify:true,
			reflectToAttribute: true
		},
		cdIndex:{
			type: Number,
			value: -1,
			notify: true,

		},
	
		selectedArray:{
			type: Array,
			value: [],
			notify: true
		},
		selected: {
			type: Array, 
			notify: true
			},
		isSelected: {
			type: Boolean,
			value: false,
			observer: "observeIsSelected",
			notify: true
		},

	},
	ready: function(){

	},
	computeInCourseCalendarDaysArray: function(calendarDay){
		if(calendarDay.inCourseCalendar===true){return true;}
		else {return false;}
	},
	computeDayNotes:function(calendarDay){
		var retVal=(calendarDay.isTestDate)?calendarDay.dateText: (calendarDay.isCourseMeeting)?calendarDay.meetingText: (calendarDay.isPracticeTestDay)?calendarDay.practiceTestText:"";
		return retVal;
	},
	observeTheDays: function(newVal,oldVal){

		if(oldVal && newVal!=oldVal)
		{
		//	console.log(oldVal, newVal);
		}



	},
	computeDayId:function(calDay)
	{	//console.log(calDay.dateId);
		return calDay.dateId;


	},
	observeIsSelected: function(newVal,oldVal){
		if(newVal===true && oldVal===false)
		{
			if(!this.event.courseCalendarDaysArray)
			{
				this.event.courseCalendarDaysArray=[];
			}
			if(!this.calendarDay)
			{
				this.set("calendarDay", new FcCalendarDay());
				this.push("event.courseCalendarDaysArray", this.calendarDay);
			}
		}
		var sortedCalDays= this.event.courseCalendarDaysArray.sort(function(a,b){
			if (a.dateId > b.dateId) {
    		return 1;
  			}
  			if (a.dateId < b.dateId) {
   	 		return -1;
  			}
  			if (a.dateId ===b.dateId){
  			  return 0;
			}
		});
		return sortedCalDays;


		
	},

	computeMiniDate: function(calendarDay){
		return calendarDay.date;


	},
	observeBackground: function(calendarDay){
		//console.log(calendarDay, calendarDay.practiceTestArray, calendarDay.meetingDayArray, this.inMonth)


	},

	
  	computePickedDaysDark: function(inMonth, calendarDay)
  	{
  		if(inMonth===true)
  		{ 

  			var retVal =(calendarDay===true)?"#008":"white";
  			return retVal;
  		}
  		else
  		{
  			
  			return "#dfdfdf";
  		}
  	},
  	isEvents: function(newVal, oldVal)
  	{
  		console.log(newVal, oldVal);
  		//this.set("events", this.events);



  	},

  	toggleDays: function(e)
  	{	
  		if(this.inMonth===true)
  		{	
  			if(!this.selectedArray){this.set("selectedArray", [])};
	  		this.toggleDay=!this.toggleDay;
	  		this.isSelected = !this.isSelected;
	  		this.set("calendarDay.toggleDay",!this.calendarDay.toggleDay);
  			this.set("calendarDay.isSelected", !this.calendarDay.isSelected);
	  		var timestamp =new Date();
	  		timestamp=timestamp.getTime();
	  		var self=this;
	  		if(this.calendarDay.isSelected===true)
	  			{	
	  				this.push("selectedArray", this.calendarDay);
	  				//console.log(this.event.courseCalendarDaysArray);
	  			}
	  		else{ var newArray= this.event.courseCalendarDaysArray.filter(function(value, index, array)
	  					{ 	var trfs=(value.date!=self.calendarDay.date);
	  						//console.log(value.date, self.calendarDay.date, trfs);
	  						return (value.date!=self.calendarDay.date);  	
						});
	  				this.set("selectedArray", null);
	  				this.set("selectedArray", newArray);
	  			}
	  			this.set("event.courseCalendarDaysArray", null);
	  			this.set("event.courseCalendarDaysArray",this.selectedArray);
	  			//console.log(this.inCourseCalendarDaysArray);
	  			this.inCourseCalendarDayArray=!this.inCourseCalendarDaysArray;
	  			//console.log(this.inCourseCalendarDaysArray);

	  	}
	  		
  	},
  	computeWhite: function(inMonth, calendarDay)
  	{
  		if(inMonth===true)
  		{
  			return "white";
  		}
  		else 
  		{
  			return "#dfdfdf";
  		}
  	},
  	computePickedDaysWhite: function(inMonth, calendarDay, testDate){
  		if(inMonth)
  		{
  			var retVal=(calendarDay===true)?"white":(testDate===true)? "red; font-weight: 700": "#008";
  			return retVal;
  		}
  		else if(inMonth==false) 
  		{
  			
  			return "#efefef";
  		}
  	},
  computeSelectedArray: function(isSelected, selected, toggleDay){
  

  }
});
 </script>
 </dom-module>
 