<dom-module id="fc-calculator">
<template>
<style>
:host{ width: 360px;background: white;}
.calcbutton {
	background: lightgray;
	border: 1px solid gray;
	max-width: 38px!important;
	width:calc(100%/4.8)!important;
	margin: 1px;
}
.opbutton{
	background: orange;
	border: 1px solid gray;
	margin: 1px;
	max-width: 44px!important;
}
paper-button{width:width:calc(100%/7)!important; max-width:calc(100%/7)!important;}
div{font-size: 16px; font-weight: 600; color: #008; background: #fcfcfc; font-family: merriweather; overflow: hidden;}
</style>
<fc-ddr-card drags=true draggable is-resizing="true" style="background:#ffffff;border-radius:15px; border: 2px ridge black; width:330px; height:440px;">
<div style="background:#ffffff;border-radius:15px; border: 2px ridge black; width:340px; height:72px">

	<input style="background:#666666; color:white; text-align:right; padding:1x; font-size:1.6em; height:32px" readonly type="text" value="{{lastExpression}}">
	<input style="background:#666666; color:white; text-align:right; padding:1px; font-size:1.6em; height:32px" readonly type="text" value="{{currentExpression}}">
</div>
	<div class="vertical layout nowrap" style=" width: 338px;">
	<div class="layout horizontal flex wrap" style=" width: 338px;">
		<paper-button raised name="AC" class="layout flex calcbutton" on-tap="doAllClear">AC</paper-button>
		<paper-button id="calcclear" raised name="C" class="layout flex shrink calcbutton" on-tap="doClear">C</paper-button>
		<paper-button raised name="^" class="flex calcbutton" on-tap="addToExpression">x<sup><i>y</i></sup></paper-button>
		<paper-button raised name="%" class="flex calcbutton" on-tap="addToExpression">%</paper-button>
	<!-- </div>
	<div class="layout horizontal"> -->
		<paper-button raised name="7" class=" flex calcbutton" on-tap="addToExpression">7</paper-button>
		<paper-button raised name="8" class="  flex calcbutton" on-tap="addToExpression">8</paper-button>
		<paper-button raised name="9" class="  flex calcbutton" on-tap="addToExpression">9</paper-button>
		<paper-button raised name="/" class="  flex opbutton" on-tap="addToExpression">&divide;</paper-button>
	<!-- </div>
	<div class="layout horizontal"> -->
		<paper-button raised class="flex calcbutton" name="4" on-tap="addToExpression">4</paper-button>
		<paper-button raised name="5" class="flex calcbutton" on-tap="addToExpression">5</paper-button>
		<paper-button raised name="6" class="flex calcbutton" on-tap="addToExpression">6</paper-button>
		<paper-button raised name="*" class="opbutton" on-tap="addToExpression">X</paper-button>
	<!-- </div>
	<div class="layout horizontal flex"> -->
		<paper-button raised name="1" class="flex calcbutton" on-tap="addToExpression">1</paper-button>
		<paper-button raised name="2" class="flex calcbutton" on-tap="addToExpression">2</paper-button>
		<paper-button raised name="3" class="flex calcbutton" on-tap="addToExpression">3</paper-button>
		<paper-button raised name="-" class="flex opbutton" on-tap="addToExpression">-</paper-button>
	<!-- </div>
	<div class="layout horizontal flex"> -->
		<paper-button raised name="0" class="flex calcbutton" on-tap="addToExpression">0</paper-button>
		<paper-button raised name="." class="flex calcbutton" on-tap="addToExpression">.</paper-button>
		<paper-button raised class="flex opbutton" on-tap="evaluateExpression">=</paper-button>
		<paper-button raised name="+" class="flex opbutton" on-tap="addToExpression">+</paper-button>

	</div>
</div>
</fc-ddr-card>

</template>
<script>

FcCalculator=Polymer({
	is: 'fc-calculator',
	//behaviors: [FCBehaviors.FCFirepadBehavior],
	observers: ['updateCurrentExpression(expressionArray.splices)'],				
	properties: {
		lastKey: {
			type: String,
			value: ""
		},
		currentExpression: {
			type: String,
			value: "0"
		},
		functionsArray: {
			type: Array, 
			value: [	
			// {key: "absoluteValue", valueFunction: "abs(x)", "displayFunction": function(inputValOrExpression), "juliusImaginary frien": "Jose""|"+ inputValOrExpression+"|"}, 
					// {key: "cosineOfX", valueFunction:"cos(x)", "displayFunction": function(inputValueOrExpression{return "cos("+ inputValueOrExpression+ ")" },

					// {key: EtoTheX, value: exp(x) note:"EtoTheX"};
					// {key: "logNaturalOfX", valueFunction: log(x), displayFunction(x,y,x){"ln("+ x.toString() + y.toString() + z.toString() ")"},
					// {key: "maximum value in a set", valueFunction: max(valueInputs); displayFunction: function(inputOrExpression){});
					// {key: "xToThePowerOfY", valueFunction: "pow(x,y)", "displayHtml.createElement("SUP")toThePower"}
					// ];
						],
				notify: true, 
			},

// acos(
// asin(x)	ADD REST WHEN HAVE CHANCE ADD CANVAS AND REGULAR MATH TO DRAW AND PLOT;
// atan(x)	
// radians
// atan2(
// ceil(x)	
// cos(x)	
// exp(x)	
// floor(x)	
// log(x)	
// x
// max(
// value
// min(
// value
// pow(
// of y
// random
// round(x)	
// sin(x)	
// sqrt(x)	
// tan(x)	}

// acos(x)	Returns the arccosine of x, in radians
// asin(x)	Returns the arcsine of x, in radians
// atan(x)	Returns the arctangent of x as a numeric value between -PI/2 and PI/2 radians
// atan2(y,x)	Returns the arctangent of the quotient of its arguments
// ceil(x)	Returns x, rounded upwards to the nearest integer
// cos(x)	Returns the cosine of x (x is in radians)
// exp(x)	Returns the value of Ex
// floor(x)	Returns x, rounded downwards to the nearest integer
// log(x)	Returns the natural logarithm (base E) of x
// max(x,y,z,...,n)	Returns the number with the highest value
// min(x,y,z,...,n)	Returns the number with the lowest value
// pow(x,y)	Returns the value of x to the power of y
// random()	Returns a random number between 0 and 1
// round(x)	Rounds x to the nearest integer
// sin(x)	Returns the sine of x (x is in radians)
// sqrt(x)	Returns the square root of x
// tan(x)	Returns the tangent of an angle}			






// 			]



		expressionArray: {
			type: Array,
			value: ["0"],
			notify: true,
			reflectToAttribute: true
		},
		lastExpression: {
			type: String,
			value: ""
		},
		operatorList: {
			type: Array,
			value: ["+", "-", "*", "/", "=", "%", "^"]
		}
	},

	attached: function ()
	{
		this.currentExpression = "0";
		this.lastExpression = "";
		this.doAllClear();
		var buttons = Polymer.dom(this).querySelectorAll(".paper-button-0");
		var numButtons = buttons.length;
		console.log("found " + numButtons + " buttons");
		var i = 0;
		for(i=0;i<numButtons;i++)
		{
			console.log(buttons[i].name, buttons[i].ontap);
			buttons[i].addOwnKeyBinding(buttons[i].name, buttons[i].ontap);
		}
	},

	addToExpression: function(e)
	{
		console.log(this.expressionArray);
		var key = e.target.getAttribute("name");
		if(this.isNumber(key))
		{
			if(this.isOperator(this.lastKey))
			{
				//this.currentExpression += " "; //spacing for aesthetics
			}
			if(this.computeCurrentExpression() == "0" || this.lastKey == "=")
			{
				this.pop("expressionArray");
				this.push("expressionArray", key);	
			}
			else
			{
				this.push("expressionArray", key);	
			}
		}
		else if(this.isOperator(key))
		{
			var elen = this.computeCurrentExpression().length;
			if(this.computeCurrentExpression() == "-" || 
				(this.lastKey == "-" && elen > 1 && (this.computeCurrentExpression()[elen-2] == "^" || this.computeCurrentExpression()[elen-2] == "*" || this.computeCurrentExpression()[elen-2] == "/")) )
			{
				//do nothing like Google calculator
				return; // don't want to update lastKey
			}
			else if( (this.lastKey == "^" || this.lastKey == "*" || this.lastKey == "/") && key == "-")
			{
				this.push("expressionArray", key);
			}
			else if(this.isOperator(this.lastKey))
			{
				this.pop("expressionArray");
				this.push("expressionArray", key);	
				//console.log(this.currentExpression);
			}
			else if (this.computeCurrentExpression() == "0" && key == "-")
			{
				this.pop("expressionArray");
				this.push("expressionArray", key);
			}
			else
			{
				this.push("expressionArray", key);	
			}
		}
		else if(key == ".")
		{
			if(this.lastKey == "=")
			{
				this.pop("expressionArray");
				this.push("expressionArray", key);
			}
			else
			{
				var currEx = this.computeCurrentExpression();
				var opLoc = this.findLastOperator(currEx);
				var decLoc = currEx.lastIndexOf(".");
				if(decLoc == -1 || opLoc > decLoc)
					//this.computeCurrentExpression().indexOf(".") == -1)
				{
					this.push("expressionArray", key);	
				}
				else
				{
					return; //already a decimal in most recent term so do nothing
				}
			}
		}
		console.log(this.expressionArray);
		this.lastKey = key;
		this.$.calcclear.removeAttribute("disabled");
	},

	findLastOperator: function(argString)
	{
		var numOps = this.operatorList.length;
		var i = 0;
		var lastLoc = -1;
		for(i=0; i<numOps;i++)
		{
			var loc = argString.lastIndexOf(this.operatorList[i]);
			if(loc > lastLoc)
			{
				lastLoc = loc;
			}
		}
		return lastLoc;
	},

	computeButtonAvailability: function()
	{
		var result = (this.lastKey == "=")? 'readonly' : '';
		return result;
	},

	computeCurrentExpression: function(argArray)
	{
		var len = this.expressionArray.length;
		var i=0;
		var result = "";
		for(i=0; i<len;i++)
		{
			result += this.expressionArray[i];
		}
		return result;
	},

	updateCurrentExpression: function(newVal)
	{
		console.log(newVal);
		this.currentExpression = this.computeCurrentExpression();
	},


	evaluateExpression: function(e)
	{
		try
		{
			if(this.lastKey == "=")
			{
				return;
			}
			var exp = this.computeCurrentExpression();
			var evaluateableExp = this.transformExpression(exp);
			var result = eval(evaluateableExp);
			this.lastExpression = exp; //this.currentExpression;
			this.set("expressionArray", []);
			this.push("expressionArray", result.toString());
			this.lastKey = "=";
			this.$.calcclear.setAttribute("disabled", true);
		}
		catch(err)
		{
			console.log(err);
			alert("Invalid mathematical expression. Please try again.");
		}
		
	},

	//possibly insert spaces or turn single symbols like square root into eval() form
	//use mathjs.js library instead??
	transformExpression: function(argExp)
	{
		var result = argExp;
		var powMatches = result.match(/((^\-)?([0-9]|\.)+|Math\.pow\(.*?\))\^\-?([0-9]|\.)+/);
		//var numPM = powMatches.length;
		while(powMatches != null)
		{
			var match = powMatches[0];
			console.log(match);
			var powLoc = match.indexOf("^");
			var op1 = match.slice(0, powLoc);
			var op2 = match.slice(powLoc+1);
			console.log(op1, "and", op2);
			result = result.replace(match, "Math.pow("+op1+","+op2+")");
			console.log(result);
			powMatches = result.match(/(([0-9]|\.)+|Math\.pow\(.*?\))\^([0-9]|\.)+/);
		}
		
		return result;
	},

	isOperator: function(argKey)
	{
		return (argKey == "+" || argKey == "-" || argKey == "*" || argKey == "/" || argKey == "^");
	},

	isNumber: function(argKey)
	{
		return (argKey == "1" || argKey == "2" || argKey == "3" || argKey == "4" || argKey == "5" || argKey == "6" || argKey == "7" || argKey == "8" || argKey == "9" || argKey == "0");
	},

	isNumberOrDecimal: function(argKey)
	{
		return (this.isNumber(argKey) || argKey == ".");
	},

	doClear: function(e)
	{
		var len = this.expressionArray.length;
		if(len != 0)
		{
			this.pop("expressionArray");
		}
		len = this.expressionArray.length;
		if(len == 0)
		{
			this.push("expressionArray", "0");
		}
		this.lastKey = this.expressionArray[len-1]; //this.currentExpression[len-1];
	},

	doAllClear: function(e)
	{
		this.set("expressionArray", ["0"]);
		this.lastKey = "0";
	}

	//doPercent: function(e)
	//{
	//	this.terms[this.currentTerm] = (parseFloat(this.terms[currentTerm]) / 100).toString();
	//},

	//doSignFlip: function(e)
	//{
	//	var value = parseFloat(this.secondOperand) * -1;
	//	this.secondOperand = value.toString();
	//},

});
</script>
</dom-module>