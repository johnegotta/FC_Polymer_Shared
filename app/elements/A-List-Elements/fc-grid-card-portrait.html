<dom-module id="fc-grid-card-portrait">
<!-- Level Concept: 
Top: Index
  1. drawer-panel (if we can get it to be the dashboard..awesome);
	    if drawer panel submerged below index could hold data transfers, help in notification and coordinate memory
	    the "data-assistant" is a design perk the kids like, which provides a calculator, note area, and place to hold data, make items
	    it could becme the rich text editor, etc for the project
  2. Dashboard
  	2.A grid holds the data transfers, does the first level of measuring distances for resizing and laying out the page.
	2.B three-pane-resizing spliter: will resize to items: fully adjustable. Must change names and organization.  Left and right in class have css meanings, that are hyper difficult to circumvent. they deal with flow alignment.  A simpler version will come from the project. I tend to love the original you made
  3. Divided areas that hold elements
  	1. bottom starboard wok in lists data and place wher ethe hand naturally goes. to me mopst natural eye and work local
  	2. bottom port place where transient input goes should resize, be animated, center and swing to top for a cee all pages of animation option on big screens. 
  	3. top viewarea: during review of designs with some of the kids and some of professionals this last week, there is a strong preference on large screens for the iconic triptic.  It is a natural eye catcher, I am totally in favory of "drawer options and bringing the possibility forward." (really i just want the drawer out of the index and into an element for scopre control). more importantly, I get the desire to remove it often, it provides however hyper scope advantage.  THe upper display area might offer that same advantage with some iframe same local options.  When I have placed the test materials in there, people do sort of ooh, and ahh.  its a thing to think about.  No baggage with a ditto as home address... we just need to hash bang further into our address for any polymer.
  	4. Elements
  		1. Portrait Card
  			a. ranging in size from 340px w and 480px H th card can grow to 660 by 720 (large tablet portrait)
  			b. card naturally works with the
  			 	i. CELL CREATOR, a label + output + input that will be the key building block of our data layout.
  				ii. the mini headers: not yet completed, bound around the edges of the fc-content-holders or the fc-cell-creators (see input card.)
  				iii. the fc-content holder, which will define our row heights and widths
  			c. Portrait Card is based on the polymer Paper card.  I have ussed the header image and title well in the fc-intake-form
  			d. portrait card works best when it holds 8-12 pieces of information
  		2. Landscape-Card/list-Tube/Course details Card/Sales Item Card
  			a.   a potential work horse, dynamically adding logic would be a godsend
  			b. 	possesses four icons with the option for 8
			c.   has "time sensitive 'temperature gauge'"
			d. 	Best used in an animated list, that compliments the tabbed view (will discuss)
		3. Mini-Card/Monopoly Card/Fast Profile Card
			a. Have always wanted this for the large view screen teacher page, but am side-lining on the large design project.  It basically is the mini card scott more or less finished, which I was working on. It's tabbed does stuff, but really is just an alert to send a teacher to the top screen.
		4. Tabbed view... This will be a big project. Lets see what we can do with the data, drag and drop, etc. I believe that will build the 
				database and the website. 
		5. Data Assistant... Pivitol 	
		6. Iron Storage for our API needs... PIVOTAL
		7. CACHE and Session For API NEEDS
Other needs we have filled ad dont use
II. Scott Native binding, John Native Binding, Pivitol
III. ALL JOHN QUESTIONS FROM POLYMER FOUR... its all the reading diced up for new tests YES I SAID THAT PIVITOL!!!
IV. SCOTTS WORK ON TEST BUILDER PIVOTAL!!!!
V. JOHNs WORK ON TEST BUILDER PIVOTAL!!!
VI. TO ACTUALLY WORK TOGETHER AND GET BEHIND A PLAN WHICH I THINK IS COMMING TOGETHER, BUT WHICH I FEEL I HAD TO COBBLE TOGETHER FROM YOUR WORK IN THE DARK...And via my own hammering out of apparently almost 80,000 lines of code... probably 23000 were dupliates... so 55,000 lines of code...\

 I cant do it this way anymore.
-->
	<template>
		<style is="custom-style">
			.grid-box{
			   width: 340px;
			   height: 480px;
			   padding: 3px;
			   margin: 3px;
			   display: block;
			   color: black;
			   background: white;
			   overflow-x: hidden;
			 }
			.grid-image{
				float: left;
				padding: 3px;
				height: 72px;
				color: black;
				width: 73px;
				background: aliceblue;
				display: block;
			}
			.grid-holder{
			   width: calc(95%-85px);
			   max-height: calc(98vh-64px);
			   overflow: scroll;
			   margin: 16px;
			}
		</style>
			<!--a good idea here would be to include the splitter for resizing below this level and perhaps only the drawer panel above it-->
			<!--my thinking here is that scopes us nicely, reveals little, and makes our jobs way easier.  The grid goes up two levels and this is easy.-->
			<firebase-collection id="scores" order-by-child="student" data='{{items}}' equal-to="jkdshi283794" location='https://focusedstaging1.firebaseio.com/test_results'></firebase-collection>
		<div class="vertical layout wrap grid-holder center center-justified">
		    <div class="horizontal layout"> 
				<paper-input id="searcher" label="Search" value="{{searchString}}" placeholder="Search Grid...">
				</paper-input>
				<paper-button on-tap="__assign">Assign New Positions
				</paper-button>
				<paper-button on-tap="go">GO!!!!
				</paper-button>
			</div>
			<fc-call-card-input-model-one>
					<fc-content-holder input-names="cells" class="horizontal layout container wrap">
<!--THIS SHOULD BE A FACTORY IMPLIMENTATION OF THE CELLS INTO WHEREVER WE NEED THEM. THIS MAKES THE MOST SENSE-->			
						<template is="dom-repeat" items="{{griditemArray}}" as="input" filter="{{doFilter(searchString)}}">
							<fc-cell-creator name="cells" draggable="true" input='{{input.val}}' fclabel='{{input.key}}' on-dragstart="handleDragStart" on-dragover="allowDrop" on-drop="handleDrop">
							</fc-cell-creator>
				  		</template>
<!--The factoryImpl ends here; perhaps factImpl the holder first, and fact impl the mini headers.  You have the arsenol of a few of those items in the grid/dashboard/modal/splitter framework and we need not much else. It remains dynamic but has binding.  It seems good. We will see.-->
					</fc-content-holder>

			</fc-call-card-input-model-one>
		</div>
<!--SHOULD BE PART OF THE ASSISTANT OR AN ASSISANT LIKE FUNCTION OR ITS OWN ELEMENT
		NEW ELEMENT. NEW ELEMENT. ASSISTANT FEATURE???  NEW ELEMENT. ASSISTANT FEATURE???
		NEW ELEMENT. ASSISTANT FEATURE??? NEW ELEMENT. ASSISTANT FEATURE??? NEW ELEMENT. ASSISTANT FEATURE???
		NEW ELEMENT. ASSISTANT FEATURE??? NEW ELEMENT. ASSISTANT FEATURE??? NEW ELEMENT. ASSISTANT FEATURE???
		-->
	<paper-dialog id="tada" no-cancel-on-outside-click="true">
		<div id="betterTada" style="min-height: 120px; min-width: 280px">
			<ul id="superTada">
		
			</ul>
		</div>
		<div class="buttons" style="height: 65px; padding: 8px 8px 8px 14px;" class="horizontal layout left-justified">
			<paper-button on-tap="conttap">Confirm Save</paper-button>
			<paper-button on-tap="__revertArray">Revert Array</paper-button>
			<paper-button dialog-dismiss on-tap="__clear">Continue Working</paper-button>
		</div>
	</paper-dialog>

	<div id="cuck">
	</div>
</template>
<script>
Polymer({
  is:"fc-grid-card-portrait",
  properties: {
    defaultPath: "",
    pathOne: "https://focusedstaging1.firebaseio.com/test_results", 
    pathTwo: String, 
    gridWidthPx: Number, 
    gridHeightPx: Number,
    scrollX: Boolean,
    scrollY: Boolean,
    isDnD: Boolean,
    fillViewPort: Boolean,
    gridImageOne: String,
    gridImageTwo: String,
    keyNames: {
	   type: Array,
	   value: Array,
	   notify: true,
	   reflectToAttributes: true
	 },
    griditemArray: {
	 type: Array,
	 value: Array,
	 notify: true,
	 reflectToAttributes: true
    },
    gridHolderArray: {
	 value: Array,
	 notify: true,
	 reflectToAttributes: true
    },
    gridRows: {
	 type: Array,
	 notify: true,
	 reflectToAttributes: true
    },
    oldGridArray: {
	 type: Array,
	 value: Array,
	 notify: true,
	 reflectToAttributes: true
	 },
    gridImageOne: '',
    gridImageTwo: '',
    searchString: {
	 type: String,
    },
      fcid: {
		 type: Array,
		 value: [],
		 notify: true,
		 reflectToAttributes: true
	 },
    currentDragger: Object,
    reflectToAttributes: true,
    notify: true

   },

  updateFilter: function(argObj){
    console.log(argObj);
    this.searchString = argObj.name;
  },

  doFilter: function(e){
   // return function(argItem){
	// var itemname = argItem.name;
	 //var search = e.toLowerCase();
	 //return (itemname.indexOf(search) > -1) 
   // };
  },
  
go: function(){
		var arrayToPrint = this.$.scores.data;
		console.log(this.$.scores.data);
		console.log(arrayToPrint);
		var record = arrayToPrint[0];
		var keys = Object.keys(record);
		var numbEntries = keys.length; 
		var counter = 0;	
	     for(counter=0; counter < numbEntries; counter++){
					this.push('griditemArray', {val: arrayToPrint[0][keys[counter]], key: keys[counter]});
					this.push('oldGridArray', {val: arrayToPrint[0][keys[counter]], key: keys[counter]});
					this.push('keyNames', keys[counter]);

		   	}
		
		console.log(this.oldGridArray);
		console.log("KNOW THE OLD ARRAY VALUE KNOW IT")
				
    		},


handleDragStart: function(e) {
	 e.dataTransfer.setData("fcdata", JSON.stringify(e.model.item));
	 //console.log("drag begun for ");
	 //console.log(e.model.item);
	 var cell = e.target;
	 console.log(e.target);
	 while(cell.nodeName != "FC-CELL-CREATOR")
	 {
	   //console.log(cell);
	   cell = cell.parentNode;
	 }
	 this.currentDragger = cell;
    }, 
allowDrop: function (e) {
	 e.preventDefault();
	 //console.log("drag over");
    },
handleDrop: function(e){
    //console.log(e.model.item);
    //console.log(e);
    var cell = e.target;
    var i = 0;
    while(cell.nodeName != "FC-CELL-CREATOR")
    {
	 cell = cell.parentNode;
	  console.log("in loop" + cell);
    }
    console.log(cell);
    //console.log("just droppped " + e.target + " on " + e.model.item.name);
    
    var temp = cell.input;
    var dataObj = JSON.parse(e.dataTransfer.getData("fcdata"));
    cell.input = dataObj.key;
    //console.log(this.currentDragger);
    this.currentDragger.input = temp;
    

  }, 

  __assign: function(){
    var i=0;
    for(i=0; i < this.griditemArray.length; i++){
    var valnow = this.griditemArray[i].val;
    var keynow = this.griditemArray[i].key;
    console.log(i + " is the index number of key " + keynow + " which has a value of " + valnow);
    var tadatwo = this.$.superTada;
    var tadathree = document.createElement("li");
    Polymer.dom(tadathree).innerHTML = "Index position " + i + " now is set to " + keynow + ". ";
    Polymer.dom(tadatwo).appendChild(tadathree);
    };
    this.$.tada.open();
  },

  __clear: function(){
    var myList  = this.$.superTada;
    Polymer.dom(myList).innerHTML = '';
    console.log(myList);
  }, 

  __revertArray: function(){
  	var myList  = this.$.superTada;
    Polymer.dom(myList).innerHTML = '';
    this.$.tada.close();
    var giAl = this.griditemArray.length
	var oGAL = this.oldGridArray.length;
	   	if (oGAL< giAl){
	   		giAl.slice(0,oGal);
	   	}
	   	var i = 0;
	   	for(i=0; i < oGAL; i++){
	   			this.giAl[i]=null;
	   			//this.push("griditemArray", {val: this.oldGridArray[i].val, key: this.oldGridArray[i].key});
	   			}
	   	for(i=0; i < oGAL; i++){
	   			this.push("griditemArray", {val: this.oldGridArray[i].val, key: this.oldGridArray[i].key});
	  		}
	  	/*for(j=0; j < this.griditemArray.length; j++){
	    	var keynow = this.griditemArray[j].key;
	    	var valnow = this.griditemArray[j]..val;
	    	console.log(j + " hgh " + this.griditemArray[j].key + " which has a value of" + this.griditemArray[j].val);
	    	var tadatwo = this.$.superTada;
	    	var tadathree = document.createElement("li");
	    	Polymer.dom(tadathree).innerHTML = "Index position key is " + this.griditemArray[j].key + " and now is set to " + this.griditemArray[j].val + ". ";
	    	Polymer.dom(tadatwo).appendChild(tadathree);
	    	}
	    }, 3000);*/

    	this.$.tada.open();
}
});
</script>
</dom-module>