<dom-module id="fc-grid">


<!-- Level Concept: 
Top: Index
  1. drawer-panel (if we can get it to be the dashboard..awesome);
	    if drawer panel submerged below index could hold data transfers, help in notification and coordinate memory
	    the "data-assistant" is a design perk the kids like, which provides a calculator, note area, and place to hold data, make items
	    it could becme the rich text editor, etc for the project
  2. Dashboard
  	2.A grid holds the data transfers, does the first level of measuring distances for resizing and laying out the page.
	2.B three-pane-resizing spliter: will resize to items: fully adjustable. Must change names and organization.  Left and right in class have css meanings, that are hyper difficult to circumvent. they deal with flow alignment.  A simpler version will come from the project. I tend to love the original you made
  3. Divided areas that hold elements
  	1. bottom starboard wok in lists data and place wher ethe hand naturally goes. to me mopst natural eye and work local
  	2. bottom port place where transient input goes should resize, be animated, center and swing to top for a cee all pages of animation option on big screens. 
  	3. top viewarea: during review of designs with some of the kids and some of professionals this last week, there is a strong preference on large screens for the iconic triptic.  It is a natural eye catcher, I am totally in favory of "drawer options and bringing the possibility forward." (really i just want the drawer out of the index and into an element for scopre control). more importantly, I get the desire to remove it often, it provides however hyper scope advantage.  THe upper display area might offer that same advantage with some iframe same local options.  When I have placed the test materials in there, people do sort of ooh, and ahh.  its a thing to think about.  No baggage with a ditto as home address... we just need to hash bang further into our address for any polymer.
  	4. Elements
  		1. Portrait Card
  			a. ranging in size from 340px w and 480px H th card can grow to 660 by 720 (large tablet portrait)
  			b. card naturally works with the
  			 	i. CELL CREATOR, a label + output + input that will be the key building block of our data layout.
  				ii. the mini headers: not yet completed, bound around the edges of the fc-content-holders or the fc-cell-creators (see input card.)
  				iii. the fc-content holder, which will define our row heights and widths
  			c. Portrait Card is based on the polymer Paper card.  I have ussed the header image and title well in the fc-intake-form
  			d. portrait card works best when it holds 8-12 pieces of information
  		2. Landscape-Card/list-Tube/Course details Card/Sales Item Card
  			a.   a potential work horse, dynamically adding logic would be a godsend
  			b. 	possesses four icons with the option for 8
			c.   has "time sensitive 'temperature gauge'"
			d. 	Best used in an animated list, that compliments the tabbed view (will discuss)
		3. Mini-Card/Monopoly Card/Fast Profile Card
			a. Have always wanted this for the large view screen teacher page, but am side-lining on the large design project.  It basically is the mini card scott more or less finished, which I was working on. It's tabbed does stuff, but really is just an alert to send a teacher to the top screen.
		4. Tabbed view... This will be a big project. Lets see what we can do with the data, drag and drop, etc. I believe that will build the 
				database and the website. 
		5. Data Assistant... Pivitol 	
		6. Iron Storage for our API needs... PIVOTAL
		7. CACHE and Session For API NEEDS
Other needs we have filled ad dont use
II. Scott Native binding, John Native Binding, Pivitol
III. ALL JOHN QUESTIONS FROM POLYMER FOUR... its all the reading diced up for new tests YES I SAID THAT PIVITOL!!!
IV. SCOTTS WORK ON TEST BUILDER PIVOTAL!!!!
V. JOHNs WORK ON TEST BUILDER PIVOTAL!!!
VI. TO ACTUALLY WORK TOGETHER AND GET BEHIND A PLAN WHICH I THINK IS COMMING TOGETHER, BUT WHICH I FEEL I HAD TO COBBLE TOGETHER FROM YOUR WORK IN THE DARK...And via my own hammering out of apparently almost 80,000 lines of code... probably 23000 were dupliates... so 55,000 lines of code...\

 I cant do it this way anymore.
-->
	<template>
		<style is="custom-style">
			.grid-box{
			   width: 340px;
			   height: 480px;
			   padding: 3px;
			   margin: 3px;
			   display: block;
			   color: black;
			   background: white;
			   overflow-x: hidden;
			 }
			.grid-image{
				float: left;
				padding: 3px;
				height: 72px;
				color: black;
				width: 73px;
				background: aliceblue;
				display: block;
			}
			.grid-holder{
			   width: calc(95%-85px);
			   max-height: calc(98vh-64px);
			   overflow: scroll;
			   margin: 16px;
			}
		</style>
		<firebase-collection id="FBscoreTwo" order-by-child="student" data='{{items}}' location='https://focusedstaging1.firebaseio.com/test_results'></firebase-collection>
		<div class="vertical layout wrap grid-holder center center-justified">
		    <div class="horizontal layout"> 
				<paper-input id="searcher" label="Search" value="{{searchString}}" placeholder="Search Grid...">
				</paper-input>
				<paper-button on-tap="__assign">Assign Now Positions
				</paper-button>
			</div>

			<fc-call-card-input-model-one>
					<fc-content-holder input-names="cells" class="horizontal layout container wrap">
						<template is="dom-repeat" items="{{griditemArray}}" filter="{{doFilter(searchString)}}">
							<fc-cell-creator name="cells" draggable="true" input='{{item.name}}' fclabel='{{item.number}}' on-dragstart="handleDragStart" on-dragover="allowDrop" on-drop="handleDrop">
							</fc-cell-creator>
				  		</template>
					</fc-content-holder>
			</fc-call-card-input-model-one>
		</div>
<!--SHOULD BE PART OF THE ASSISTANT OR AN ASSISANT LIKE FUNCTION OR ITS OWN ELEMENT
		NEW ELEMENT. NEW ELEMENT. ASSISTANT FEATURE???  NEW ELEMENT. ASSISTANT FEATURE???
		NEW ELEMENT. ASSISTANT FEATURE??? NEW ELEMENT. ASSISTANT FEATURE??? NEW ELEMENT. ASSISTANT FEATURE???
		NEW ELEMENT. ASSISTANT FEATURE??? NEW ELEMENT. ASSISTANT FEATURE??? NEW ELEMENT. ASSISTANT FEATURE???
		-->
	<paper-dialog id="tada" no-cancel-on-outside-click="true">
		<div id="betterTada" style="min-height: 120px; min-width: 280px">
			<ul id="superTada">
		
			</ul>
		</div>
		<div class="buttons" style="height: 65px; padding: 8px 8px 8px 14px;" class="horizontal layout left-justified">
			<paper-button on-tap="conttap">Confirm Save</paper-button>
			<paper-button on-tap="back">Revert Array</paper-button>
			<paper-button dialog-dismiss on-tap="__clear">Continue Working</paper-button>
		</div>
	</paper-dialog>

</template>
<script>
Polymer({
  is:"fc-grid",
  properties: {
    defaultPath: "https://focusedstaging1.firebaseio.com/test_results",
    pathOne: "https://focusedstaging1.firebaseio.com/test_results", 
    pathTwo: String, 
    gridWidthPx: Number, 
    gridHeightPx: Number,
    scrollX: Boolean,
    scrollY: Boolean,
    isDnD: Boolean,
    fillViewPort: Boolean,
    gridImageOne: String,
    gridImageTwo: String,
    griditemNumber: {
	   type: Number,
	   notify: true,
	   reflectToAttributes: true
	 },
    griditemArray: {
	 value: Array,
	 notify: true,
	 reflectToAttributes: true
    },
    superGridItemHolderArray: {
	 value: Array,
	 notify: true,
	 reflectToAttributes: true
    },
    gridRows: {
	 type: Array,
	 notify: true,
	 reflectToAttributes: true
    },
    fcids: {
      type: Array,
      notify: true,
      value: [],
      reflectToAttributes: true
    },
    scores: {
      type: Array,
      value: [],
      notify: true,
      reflectToAttributes: true
      },
    searchString: {
      type: String,
      observer: 'filterGridContent'
    },
    newOrderArray: {
	 type: Array,
	 value: [],
	 notify: true,
	 reflectToAttributes: true
	 },
    fcid: {
		 type: Array,
		 value: [],
		 notify: true,
		 reflectToAttributes: true
	},
    currentDragger: Object,
    reflectToAttributes: true,
    notify: true

   },

  updateFilter: function(argObj){
    console.log(argObj);
    this.searchString = argObj.name;
  },

/*
  doFilter: function(e){
    console.log(e);
    return function(argItem){
      //console.log(argItem.fcid);
      //console.log(e);
      var fcid = argItem.fcid.toLowerCase();
      var search = e.toLowerCase();
      return (fcid.indexOf(search) > -1) //argItem.fcid == "GanaMary00001" || argItem.fcid == "StreelandAnna00001");
    };
  },
  */

  filterGridContent: function(e)
  {
    //console.log(e.target.value);
    console.log(e);
    /*
    this.$.searcher.filter = function(e){
      return false;
    };
    */
  },

  showTime: function(e){
        var path = this.pathThree;
        console.log(path + " this is the additive path");
        var fcid = e.detail.childSnapshot.key();
        console.log(fcid);
        this.fcid=fcid;
        var firebasepath= this.pathThree + this.fcid;
        console.log(firebasepath);
        this.firebasepath = firebasepath;
        var ref = new Firebase("#!" + firebasepath);
        ref.orderByKey().startAt("real").endAt("scores\uf8ff").on("child_added", function(snapshot) {
        if(snapshot.exists() == false){
          var liToAddTwo = document.createElement('li');
            var showerTwo = document.getElementById('showIndicesTwo');
           console.log(fcid + ' and fcid ' + fcid);
            liToAddTwo.innerHTML = this.fcid + " " + "Did not take Test!!!";
            Polymer.dom(showerTwo).appendChild(liToAddTwo);
        }
        else if (snapshot.val()!== null) {
          var liToAdd = document.createElement('li');
          var shower = document.getElementById('showIndices');
          console.log(fcid + " just got scores");
          //here we can set local object arrays, or object objects
        liToAdd.innerHTML = fcid + " " + snapshot.key() +": " + snapshot.val();
           Polymer.dom(shower).appendChild(liToAdd);
           this.fcid = fcid;
        }
        //I dont get why nothing happens in this else? save that since there is no snapshot there is no function and the game ends there.
        
        });
    },

  doFilter: function(e){
    return function(argItem){
	   var itemname = argItem.name;
	   var search = e.toLowerCase();
	   //return (itemname.indexOf(search) > -1) 
        return true;
    };
  },
  
ready: function(){
	var theSet = this.$.FBscoreTwo.data;
	console.log(theSet);
	var mql = window.matchMedia("screen and (min-width: 601px) and (max-width: 800px");
	var mqlone = window.matchMedia("screen and (min-width: 801px) and (max-width: 1200px");
	var mgltwo = window.matchMedia("screen and (min-width: 1201px) and (max-width: 1600px");
	var mglthree = window.matchMedia("screen and (min-width: 1601px) and (max-width: 1900px");
	var mglfour = window.matchMedia("screen and (min-width: 1901px)");
	  	if (mglfour.matches){ // if media query matches
	 	this.gridWidthPx= 1940 + 'px';
	 	this.gridHeightPx= 1480 +'px';
	 	var numbcols = Math.round(1920/430);
	 	var numbrows = Math.round(1480/710);
	 	var limit = Math.round(numbcols*numbrows);
	 	console.log(limit);
	     var counter = 0;
	     for(counter=0; counter<limit ;counter++){
					this.push('superGridItemHolderArray', {key: counter});
		   		
		   			}
		   		}
    			
    	
  else {
	 this.gridWidthPx = 770 + 'px';
	 this.gridHeightPx = 1200 + 'px';
	 var numbcols = Math.round(320/160);
	 var numbrows = Math.round(480/96);
	 var total = Math.round(numbcols*numbrows);
	 var counter = 0; 
	 for(counter=0; counter < total; counter++){
	   //this.griditemArray[counter] = {'name': counter};
	   
	   this.push('superGridItemArray', {key: counter});
	   //console.log("this is the grid item counter in the grid element at ready " + JSON.stringify(this.griditemArray[counter]));
	   //console.log("this is the grid item name in the grid element at ready " + this.griditemArray[counter].name);
	   console.log("this is the grid number at ready in the grid " + this.superGridItemNumber);
	 }
    }
},
/*
attached: function(){
	var theSet = this.$.FBscoreTWO.data;
	console.log(theSet);
},
*/

handleDragStart: function(e) {
	 e.dataTransfer.setData("fcdata", JSON.stringify(e.model.item));
	 //console.log("drag begun for ");
	 //console.log(e.model.item);
	 var cell = e.target;
	 console.log(e.target);
	 while(cell.nodeName != "FC-CELL-CREATOR")
	 {
	   //console.log(cell);
	   cell = cell.parentNode;
	 }
	 this.currentDragger = cell;
},

allowDrop: function (e) {
	 e.preventDefault();
	 //console.log("drag over");
},

  handleDrop: function(e)
  {
    //console.log(e.model.item);
    //console.log(e);
    var cell = e.target;
    var i = 0;
    while(cell.nodeName != "FC-CELL-CREATOR")
    {
      i++;
      cell = cell.parentNode;
      if(i > 5) break;
    }
    console.log(cell);
    console.log("just droppped " + e.target + " on " + e.model.item.name);
    var temp = cell.input;
    var dataObj = JSON.parse(e.dataTransfer.getData("fcdata"));
    cell.input = dataObj.name;
    //console.log(this.currentDragger);
    this.currentDragger.input = temp;
  },

  __assign: function(){
    var i=0;
    for(i=0; i < this.griditemArray.length; i++){
    var namenow = this.griditemArray[i].name;
    console.log(i + " is the index number of " + namenow);
    var tadatwo = this.$.superTada;
    var tadathree = document.createElement("li");
    Polymer.dom(tadathree).innerHTML = "Index position " + i + " now is set to " + namenow + ". ";
    Polymer.dom(tadatwo).appendChild(tadathree);
    };
    this.$.tada.open();
  },

  __clear: function(){
    var myList  = this.$.superTada;
    Polymer.dom(myList).innerHTML = '';
    console.log(myList);
  }
});
</script>
</dom-module>