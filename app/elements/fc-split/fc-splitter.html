<dom-module id="fc-splitter">
<template>
    <style is="custom-style">

    </style>
  
  <div id="splitHolder" class="layout flex-box container" style="width:100%; height:100vh;">
        <div id="left">
            <content style="height: 100%;" select=".left"></content>
        </div>
        <div id="draggy" draggable="true" style="background:#9dbced" on-mouseover="useSplitCursor" on-mouseleave="leaveGutter" on-mousedown="startDragging">
        </div>
        <div id="right">
            <content select=".right"></content>
        </div>
    </div>

</template>

<script>
  Polymer({
    is: 'fc-splitter',

    listeners: {"mouseleave": "mouseLeave",
                "mouseenter": "mouseEnter",
                "mouseup": "stopDragging"},

    properties: {
      left: Object,
      right: Object,
      orientation: String,
      width: Number,
      height: Number,
      minPanePercent: Number,
      maxPanePercent: Number,
      minWidth: Number,
      maxWidth: Number,
      minHeight: Number,
      maxHeight: Number,
      gutterWidth: {
        type: String,
        reflectToAttributes: true,
        value: "6px"
      },
      gutterWidthNum: Number,
      dragging: Boolean,
      borderType: String,
      x: Number,
      y: Number,
	  reflectToAttributes: true,
	  notify: true
    },

    attached: function(){
      console.log("fc-splitter attached, orientation is " + this.orientation);
      this.left = this.$.left;//document.querySelector("#uno");
      this.right = this.$.right; //document.querySelector("#dos");
      this.dragging = false;

      this.minPanePercent = 20;
      this.maxPanePercent = 80;
      this.$.splitHolder.style.border = this.borderType == "" ? "10px groove #aecdfe" : this.borderType; //E5E4E2
      if(this.gutterWidth == "")
      {
        this.gutterWidth = "8px";
      }
      console.log("gutterWidth = " + this.gutterWidth);

      this.gutterWidthNum = parseInt(this.gutterWidth.replace("px",""));
      if(this.orientation == "")
      {
        this.orientation = "horizontal";
      }
      if(this.orientation == "vertical")
      {
        this.$.splitHolder.className = "layout vertical";
        var totalHeightStr = this.style.height.replace("px","");
        var th = parseInt(totalHeightStr);
        th -= this.gutterWidthNum;
        this.$.draggy.style.width = "100%";
        this.$.draggy.style.height = this.gutterWidth;
        this.$.draggy.style.borderTop = "4px groove #aecdfe";
        this.$.draggy.style.borderBottom = "4px groove #aecdfe";

        this.$.left.style.height = "50%";
        var lh = th / 2;
        //this.$.left.style.height = lh.toString() + "px";
        this.$.left.style.width = "100%";
        this.$.right.style.height = "50%";
        var rh = th - lh;
        //this.$.right.style.height = rh.toString() + "px";
        this.$.right.style.width = "100%";
      }
      else if(this.orientation == "horizontal")
      {
        console.log("setting gutter properties for horizontal");
        var totalWidthStr = this.style.width.replace("px","");
        var tw = parseInt(totalWidthStr);
        console.log("total width = " + tw);
        tw -= this.gutterWidthNum;
        this.$.splitHolder.className = 'layout horizontal';
        this.$.draggy.style.width = this.gutterWidth;
        console.log("gutterWidth = " + this.$.draggy.style.width);
        this.$.draggy.style.height = "100%";
        this.$.draggy.style.borderLeft = "4px groove #aecdfe";
        this.$.draggy.style.borderRight = "4px groove #aecdfe";

        this.$.left.style.height = "100%";
        this.$.left.style.width = "50%";
        var lw = tw / 2;
        this.$.right.style.height = "100%";
        this.$.right.style.width = "50%"; 
        var rw = tw - lw;
        console.log(rw);
      }
      console.log(this.left);
      console.log(this.right);
    },

    useSplitCursor: function(){
        if(this.orientation == "horizontal")
        {
            this.style.cursor = "ew-resize";
        }
        else if(this.orientation == "vertical")
        {
            this.style.cursor = "ns-resize";
        }
    },

    useAutoCursor: function()
    {
        if(true) //!this.dragging)
        {
            this.style.cursor = "auto";
        }
    },

    mouseLeave: function(e)
    {
        if(this.dragging)
        {
            console.log(e);
            this.useAutoCursor();
        }
    },

    leaveGutter: function(e)
    {
        if(this.dragging == false)
        {
            this.useAutoCursor();
        }
    },

    startDragging: function(e){
            console.log("fc-splitter startDragging");
            e.preventDefault();
            this.dragging = true;
            this.useSplitCursor();
            //this.$.draggy.elevation = 100;
            // Calculate the pairs' width, and percentage of the parent width

            //this.width = this.left.getBoundingClientRect().width + this.right.getBoundingClientRect().width + this.gutterWidth;
            var gw = this.gutterWidth;

            gw = gw.replace("px", "");
            if(this.orientation == "horizontal")
            {
                var lw = Math.round(this.left.getBoundingClientRect().width);
                //var rw = this.right.style.width;
                var rw = Math.round(this.right.getBoundingClientRect().width);
                //rw = rw.replace("px", "");
                var totalWidth = parseInt(lw) + parseInt(rw) + parseInt(gw);
                this.width = totalWidth;
                this.minWidth = this.minPanePercent * totalWidth;
                this.minWidth = Math.round(this.minWidth);
                this.maxWidth = this.width - this.minWidth - parseInt(gw);
                //this.maxPanePercent * totalWidth;
                this.maxWidth = Math.round(this.maxWidth);
                console.log("minWidth = " + this.minWidth + " maxWidth = " + this.maxWidth);
                console.log("lw = " + lw + " rw = " + rw + " this.width = " + this.width);
                //this.percentage = Math.min(this.width / this.parent.clientWidth * 100, 100);
                this.x = this.left.getBoundingClientRect().left;
                //console.log("this.x = " + this.x);
            }
            else if(this.orientation == "vertical")
            {
                var lh = Math.round(this.left.getBoundingClientRect().height);
                var rh = Math.round(this.right.getBoundingClientRect().height);
                var totalHeight = parseInt(lh) + parseInt(rh) + parseInt(gw);
                this.height = totalHeight;
                this.minHeight = this.minPanePercent * this.height;
                this.minHeight = Math.round(this.minHeight);
                this.maxHeight = this.height - this.minHeight - parseInt(gw);
                this.maxHeight = Math.round(this.maxHeight);
                console.log("minHeight = " + this.minHeight + " maxHeight = " + this.maxHeight);
                console.log("this.height = " + this.height);
                this.y = this.left.getBoundingClientRect().top;
            }
            this.addEventListener("mousemove", this.drag);

    /*          this.left.addEventListener('selectstart', this.preventSelection);
                this.left.addEventListener('dragstart', this.preventSelection);
                this.right.addEventListener('selectstart', this.preventSelection);
                this.right.addEventListener('dragstart', this.preventSelection);
    */
            this.left.style.userSelect = 'none';
            this.left.style.webkitUserSelect = 'none';
            this.left.style.MozUserSelect = 'none';

            this.right.style.userSelect = 'none';
            this.right.style.webkitUserSelect = 'none';
            this.right.style.MozUserSelect = 'none';

    },

    stopDragging: function(e){
            if(this.dragging == false)
            {
                return;
            }
            if(e.target.id != "draggy")
            {
                //no longer hovering over gutter/splitter, so normal cursor
                this.useAutoCursor();
                console.log("stopDragging auto cursor");
            }
            this.dragging = false;
            //this.useAutoCursor();
            console.log("stopDragging");
            this.removeEventListener("mousemove", this.drag);

/*
            this.left.removeEventListener('selectstart', this.preventSelection);
            this.left.removeEventListener('dragstart', this.preventSelection);
            this.right.removeEventListener('selectstart', this.preventSelection);
            this.right.removeEventListener('dragstart', this.preventSelection);
*/
            this.left.style.userSelect = '';
            this.left.style.webkitUserSelect = '';
            this.left.style.MozUserSelect = '';

            this.right.style.userSelect = '';
            this.right.style.webkitUserSelect = '';
            this.right.style.MozUserSelect = '';
    },

    mouseEnter: function(e){
        console.log("mouseEnter dragging = " + this.dragging + " for id = " + this.id);
        if(e.which == 1 || e.buttons == 1 || e.button == 1)
        {
            //mouse button pressed. do nothing, drag continues
            if(this.dragging == true)
            {
                this.useSplitCursor();
            }
        }
        else
        {
            if(this.dragging)
            {
                this.dragging = false;
                this.useAutoCursor();
            }
        }
    },

    drag: function(e){
            if (this.dragging == false) return;
            //console.log(this.$.draggy.style.width);
            //console.log(this.$.draggy.getBoundingClientRect());
            // If within snapOffset of min or max, set offset to min or max
/*
            if (offsetX <=  this.leftMin + options.snapOffset) {
                offsetX = this.leftMin;
            } else if (offsetX >= this.width - this.rightMin - options.snapOffset) {
                offsetX = this.width - this.rightMin;
            }

             For first and last pairs, left and right gutter width is half.

            var leftGutterWidth = options.gutterWidth;
            var rightGutterWidth = options.gutterWidth;

            if (this.isFirst) {
                leftGutterWidth = options.gutterWidth / 2;
            }

            if (this.isLast) {
                rightGutterWidth = options.gutterWidth / 2;
            }
*/
            var gws = this.gutterWidth.replace("px", "");
            var gw = parseInt(gws);
            if(this.orientation == "horizontal")
            {
                // Get  relative position of event from the left side of the pair.
                var offsetX = e.clientX - this.x - (gw / 2);
                // Left width is the same as offset. Right width is total width - left width.
                // Both widths are calculated from the initial parent percentage.
                //this.left.style.width = 'calc(' + (offsetX / this.width * this.percentage) + '% - ' + leftGutterWidth + 'px)';
                var percentWidth = offsetX / this.width;
                percentWidth *= 100;
                percentWidth = Math.round(percentWidth);
                percentWidth = percentWidth < this.minPanePercent ? this.minPanePercent : percentWidth;
                percentWidth = percentWidth > this.maxPanePercent ? this.maxPanePercent : percentWidth;
                //console.log("percentWidth = " + percentWidth);
                var newLeftWidth = offsetX - (gw/2);
                newLeftWidth = Math.round(newLeftWidth);

                newLeftWidth = newLeftWidth < this.minWidth ? this.minWidth : newLeftWidth;
                newLeftWidth = newLeftWidth > this.maxWidth ? this.maxWidth : newLeftWidth;
                //var newLeftWidthString = newLeftWidth.toString() + "px";
                var newLeftWidthString = percentWidth.toString() + "%";
                //console.log("newLeftWidthString = " + newLeftWidthString);
                this.left.style.width = newLeftWidthString; //'calc(' + (offsetX / this.width * this.percentage) + '% - ' + leftGutterWidth + 'px)';
                //console.log("just set left width to " + this.left.style.width);

                //this.right.style.width = 'calc(' + (this.percentage - (offsetX / this.width * this.percentage)) + '% - ' + rightGutterWidth + 'px)';
                var newRightWidth = this.width - newLeftWidth; // - (gw/2);
                var rightPercentWidth = 100 - percentWidth;
                //var newRightWidthString = newRightWidth.toString() + "px";
                var newRightWidthString = rightPercentWidth.toString() + "%";
                //console.log("newRightWidthString = " + newRightWidthString);
                this.right.style.width = newRightWidthString; //'calc(' + (this.percentage - (offsetX / this.width * this.percentage)) + '% - ' + rightGutterWidth + 'px)';
            }
            else if(this.orientation == "vertical")
            {
                var offsetY = e.clientY - this.y;
                offsetY = Math.round(offsetY);
                var percentHeight = offsetY / this.height;
                percentHeight *= 100;
                percentHeight = Math.round(percentHeight);
                percentHeight = percentHeight < this.minPanePercent ? this.minPanePercent : percentHeight;
                percentHeight = percentHeight > this.maxPanePercent ? this.maxPanePercent : percentHeight;
                console.log("top percentHeight = " + percentHeight);
                var newTopHeight = offsetY - (gw/2);
                newTopHeight = Math.round(newTopHeight);

                newTopHeight = newTopHeight < this.minHeight ? this.minHeight : newTopHeight;
                newTopHeight = newTopHeight > this.maxHeight ? this.maxHeight : newTopHeight;
                //var newTopHeightString = newTopHeight.toString() + "px";
                var newTopHeightString = percentHeight.toString() + "%";
                this.left.style.height = newTopHeightString;

                var newBottomHeight = this.height - newTopHeight - (gw/2);
                var bottomPercentHeight = 100 - percentHeight;
                //var newRightHeightString = newRightHeight.toString() + "px";
                var newBottomHeightString = bottomPercentHeight.toString() + "%";
                this.right.style.height = newBottomHeightString;
            }
    },

    preventSelection: function(){
            return false;
    }

  });
</script>
</dom-module>
